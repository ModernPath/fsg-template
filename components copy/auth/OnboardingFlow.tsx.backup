'use client';

import React, { useState, useEffect, useCallback, Fragment } from 'react';
import { useRouter, useParams } from 'next/navigation';
import { useTranslations } from 'next-intl';
import { createClient } from '@/utils/supabase/client';
import { useAuth } from '@/components/auth/AuthProvider';
import { TurnstileWidget } from '@/components/ui/turnstile';
import { CheckCircleIcon, ArrowRightIcon, DocumentTextIcon, CloudArrowUpIcon, CurrencyDollarIcon, UserIcon, BuildingOffice2Icon, BuildingOfficeIcon, ExclamationCircleIcon, ChartBarIcon } from '@heroicons/react/24/outline';
import { Combobox, Transition } from '@headlessui/react';
import { CheckIcon, ChevronUpDownIcon, ChevronRightIcon } from '@heroicons/react/20/solid';
import { debounce } from 'lodash-es';
import { Spinner } from '@/components/ui/spinner';
import { 
  FileText, 
  Upload, 
  CheckCircle, 
  AlertCircle, 
  XCircle, 
  Trash2,
  FileUp,
  AlertTriangle,
  Loader2
} from 'lucide-react';
import { cn } from '@/lib/utils';
import Step1Signup from './onboarding/Step1Signup'; // Import the new component
import Step2CompanyInfo from './onboarding/Step2CompanyInfo';
import Step3PreAnalysis from './onboarding/Step3PreAnalysis'; // Import new analysis step
import Step4FundingNeeds from './onboarding/Step3FundingNeeds'; // Renamed from Step3FundingNeeds
import Step5DocumentUpload from './onboarding/Step4DocumentUpload'; // Renamed from Step4DocumentUpload
import Step6Summary from '@/components/auth/onboarding/Step5Summary'; // Renamed from Step5Summary
import Step7Application from '@/components/auth/onboarding/Step6Application'; // Renamed from Step6Application
import Step8KycUbo, { UboData } from './onboarding/Step7KycUbo'; // Renamed from Step7KycUbo
import { toast } from '@/components/ui/use-toast';
import {
  ClipboardDocumentListIcon, // Icon for Summary
  PencilSquareIcon,          // Icon for Application
  IdentificationIcon        // Icon for KYC/UBO
} from '@heroicons/react/24/outline';
import { Button } from '@/components/ui/button';
// --- ADDED: Import Realtime types --- 
import type { RealtimeChannel, RealtimePostgresChangesPayload } from '@supabase/supabase-js';
// --- RESTORED: Import the loader ---
import EuroWhirlwindLoader from '@/components/ui/EuroWhirlwindLoader'; 

// Type for our step data
type StepData = {
  title: string;
  icon: React.ElementType;
  description: string;
};

// Initial registration form data
// --- MODIFICATION: Update type definition ---
type InitialFormData = {
  firstName: string;
  lastName: string;
  phone: string;
  email: string;
  consentMarketing: boolean;
  consentAnalysis: boolean;
};
// --- END MODIFICATION ---

// Document upload data
type DocumentFormData = {
  // Removed fiscalYear and fiscalPeriod fields
};

// Funding needs form data
type FundingFormData = {
  fundingNeeds: string;
  purpose: string;
  amount: number;
  timeline: string;
  factoring_monthlyInvoices?: number;
  factoring_paymentDays?: number;
  factoring_customerLocation?: string;
};

// --- NEW Type for Step 7 --- 
type KycUboFormData = {
  applicantNationalId: string;
  ubos: UboData[];
};

// --- EXPORTED Type ---
// Application details form data (Step 6)
export type ApplicationFormData = {
  amount: number | string; // Allow string for input flexibility
  term_months: number | string; // Allow string for input flexibility
  funding_recommendation_id?: string | null; // Optional ID if started from a recommendation
};

// Interface for company search results
interface CompanySearchResult {
  businessId: string;
  name: string;
  address: string; // primary address (type 1)
  postalAddress?: string; // postal address (type 2)
  registrationDate?: string;
  status?: string;
  website?: string;
  euId?: string;
  companyForm?: string;
  mainBusinessLine?: string;
  // Address details
  postCode?: string;
  city?: string;
  street?: string;
  buildingNumber?: string;
  entrance?: string;
  apartmentNumber?: string;
  // Postal address details
  postalPostCode?: string;
  postalCity?: string;
  postalStreet?: string;
  postalBuilding?: string;
  countryCode?: string;
}

// First, create a common input class to be used across all steps
const inputClasses = "w-full px-5 py-3 text-lg text-gold-primary bg-gray-very-dark border border-gray-dark rounded-lg focus:ring-gold-primary/20 focus:border-gold-primary focus:bg-black transition-colors placeholder-gray-dark";
const selectClasses = "w-full px-5 py-3 text-lg text-gold-primary bg-gray-very-dark border border-gray-dark rounded-lg focus:ring-gold-primary/20 focus:border-gold-primary focus:bg-black transition-colors appearance-none";
const textareaClasses = "w-full px-5 py-3 text-lg text-gold-primary bg-gray-very-dark border border-gray-dark rounded-lg focus:ring-gold-primary/20 focus:border-gold-primary focus:bg-black transition-colors placeholder-gray-dark";

// Type for Company row (adjust if needed based on actual schema)
export type CompanyRow = {
  id: string;
  name?: string; // Allow undefined, to match expected type
  business_id?: string; // Allow undefined, but not null
  // Add other relevant fields fetched
  [key: string]: any;
};

// Add a helper function to display errors properly
const DisplayError = ({ error }: { error: string | null }) => {
  if (!error) return null;
  return (
    <div
      className="text-red-500 text-sm p-4 bg-red-900/20 border border-red-500/50 rounded-lg"
      dangerouslySetInnerHTML={{ __html: error }}
    />
  );
};

export default function OnboardingFlow() {
  // Get router and translations
  const router = useRouter();
  const { locale } = useParams();
  const t = useTranslations('Onboarding');
  const { session, user, loading: authLoading } = useAuth();
  const supabase = createClient();

  // State management
  const [currentStep, setCurrentStep] = useState(1);
  // --- MODIFICATION: Update state initialization ---
  const [initialFormData, setInitialFormData] = useState<InitialFormData>({
    firstName: '',
    lastName: '',
    phone: '',
    email: '',
    consentMarketing: false,
    consentAnalysis: false,
  });
  // --- END MODIFICATION ---
  const [documentFormData, setDocumentFormData] = useState<DocumentFormData>({
    // Empty object since we removed the fields
  });
  const [fundingFormData, setFundingFormData] = useState<FundingFormData>({
    fundingNeeds: '',
    purpose: '',
    amount: 0,
    timeline: '',
  });
  const [companyFormData, setCompanyFormData] = useState({ 
    name: '', 
    code: '', 
    selectedCompany: null as CompanySearchResult | null 
  });
  const [companySearchQuery, setCompanySearchQuery] = useState('');
  const [companySearchResults, setCompanySearchResults] = useState<CompanySearchResult[]>([]);
  const [isCompanySearchLoading, setIsCompanySearchLoading] = useState(false);
  
  const [loading, setLoading] = useState<boolean>(false); // Initialize loading to false
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [uploadedFiles, setUploadedFiles] = useState<File[]>([]);
  const [turnstileToken, setTurnstileToken] = useState<string | null>(null);
  const [companyId, setCompanyId] = useState<string | null>(null);
  const [companyData, setCompanyData] = useState<CompanyRow | null>(null);
  const [isAnalysisRunning, setIsAnalysisRunning] = useState(false);
  const [analysisResult, setAnalysisResult] = useState<any>(null);
  const [realtimeChannel, setRealtimeChannel] = useState<any>(null);

  // Add state for Step 6 application details
  const [applicationFormData, setApplicationFormData] = useState<ApplicationFormData>({
    amount: '',
    term_months: '', // Initial state is empty string
    funding_recommendation_id: null,
  });
  // Add state to store fetched recommendations for Step 5
  const [fundingRecommendations, setFundingRecommendations] = useState<any[]>([]);
  const [isFetchingRecommendations, setIsFetchingRecommendations] = useState<boolean>(false);
  // --- ADDED: State for Application ID ---
  const [applicationId, setApplicationId] = useState<string | null>(null);

  // Add a state variable to track if the step has been initialized from URL
  const [stepInitializedFromUrl, setStepInitializedFromUrl] = useState(false);

  // Add new state variables for drag and drop
  const [isDragging, setIsDragging] = useState(false);
  const [documentTypes, setDocumentTypes] = useState<any[]>([]);
  // Rename state to hold an array of financial data objects
  const [financialDataArray, setFinancialDataArray] = useState<any[]>([]); // Initialize as empty array
  const [isFetchingFinancials, setIsFetchingFinancials] = useState<boolean>(false);
  const [isAnalyzing, setIsAnalyzing] = useState(false); // State for initial analysis button click/API call
  const [analysisSuccess, setAnalysisSuccess] = useState(false);
  const [uploading, setUploading] = useState(false);
  const [documents, setDocuments] = useState<any[]>([]);
  const [isUploading, setIsUploading] = useState<boolean>(false);
  const [uploadProgress, setUploadProgress] = useState<number>(0);
  const [isFetchingDocuments, setIsFetchingDocuments] = useState<boolean>(false);
  const [isFetchingDocTypes, setIsFetchingDocTypes] = useState<boolean>(false);
  const [isPollingFinancials, setIsPollingFinancials] = useState<boolean>(false); // New state for polling

  // --- ADDED: State to track if navigation from realtime recommendation is pending ---
  const [pendingRecommendationNavigation, setPendingRecommendationNavigation] = useState(false);

  // --- ADDED: State to store the ID from Step 4 --- 
  const [financingNeedsId, setFinancingNeedsId] = useState<string | null>(null);
  // --- END ADDED State ---

  // --- REMOVED: State for document polling ---
  // const [isPollingDocuments, setIsPollingDocuments] = useState<boolean>(false);
  // const [pendingDocumentIds, setPendingDocumentIds] = useState<string[]>([]); // Track IDs being processed

  // Add missing state variables for companies
  const [userCompanies, setUserCompanies] = useState<CompanyRow[]>([]);
  const [isFetchingCompanies, setIsFetchingCompanies] = useState<boolean>(false);

  // --- Add state for Step 7 --- 
  const [kycUboFormData, setKycUboFormData] = useState<KycUboFormData>({
    applicantNationalId: '',
    ubos: [],
  });
  // --- End state for Step 7 ---

  // --- ADD state for Step 6 Funding Type ---
  // Default to business_loan so there's always a valid selection when reaching step 6
  const [fundingType, setFundingType] = useState<string>('business_loan'); 
  // --- END ADD state ---

  // --- NEW State to hold the latest application data saved in Step 6 ---
  const [latestApplicationData, setLatestApplicationData] = useState<any | null>(null);

  // --- NEW State to manage navigation after async state update ---
  const [nextStepTarget, setNextStepTarget] = useState<number | null>(null);

  // --- NEW State to trigger data refetch --- 
  const [refetchTrigger, setRefetchTrigger] = useState<number>(0);

  // --- MOVED: State for Recommendation Loader (from Step4) ---
  const [isGeneratingRecommendations, setIsGeneratingRecommendations] = useState(false); // State for background generation

  // Add new state to store analysis timestamp
  const [analysisStartTimestamp, setAnalysisStartTimestamp] = useState<number | undefined>(undefined);

  // Step definitions
  // --- MODIFIED: Update step definitions for new order ---
  const steps: StepData[] = [
    {
      title: t('step1.title'),
      icon: UserIcon,
      description: t('step1.description'),
    },
    {
      title: t('step2.title', { default: 'Company Info' }),
      icon: BuildingOffice2Icon,
      description: t('step2.description', { default: 'Please provide your company details.' }),
    },
    { // NEW Step 3: Preliminary Analysis
      title: t('preAnalysis.title', { default: 'Preliminary Company Analysis' }),
      icon: ChartBarIcon,
      description: t('preAnalysis.description', { default: 'Review your company\'s information before proceeding.' }),
    },
    { // NEW Step 4: Funding Needs (was Step 3)
      title: t('step4.title'), // Use original step 4 title
      icon: CurrencyDollarIcon,
      description: t('step4.description'), // Use original step 4 description
    },
    { // NEW Step 5: Document Upload (was Step 4)
      title: t('step3.title'), // Use original step 3 title
      icon: DocumentTextIcon,
      description: t('step3.description'), // Use original step 3 description
    },
    { // NEW Step 6: Summary (was Step 5)
      title: t('step5.title', { default: 'Summary & Recommendations' }),
      icon: ClipboardDocumentListIcon,
      description: t('step5.description', { default: 'Review summary and funding options.' }),
    },
    { // NEW Step 7: Application (was Step 6)
      title: t('step6.title', { default: 'Application Details' }),
      icon: PencilSquareIcon,
      description: t('step6.description', { default: 'Specify application amount and term.' }),
    },
    { // NEW Step 8: KYC/UBO (was Step 7)
      title: t('step7.title', { default: 'Verification & Submit' }),
      icon: IdentificationIcon,
      description: t('step7.description', { default: 'Confirm details and submit.' }),
    },
  ];
  // --- END MODIFIED ---

  // Simplified step initialization logic - only respect URL parameters
  useEffect(() => {
    if (authLoading) return;
    
    // Get URL parameter for step if available
    const params = new URLSearchParams(window.location.search);
    const stepParam = params.get('step');
    const stepFromUrl = stepParam && !isNaN(Number(stepParam)) ? Number(stepParam) : null;
    
    // Simple step determination
    let initialStep = stepFromUrl && stepFromUrl >= 1 && stepFromUrl <= 8 ? stepFromUrl : 1; // Increased max step to 8
    
    // Only basic auth check - authenticated users shouldn't see step 1
    if (session && user && initialStep === 1) {
      initialStep = 2;
    }
    
    // Always fetch company data for authenticated users
    if (session && user) {
      fetchUserCompanies();
    }
    
    // Apply the determined step
    setCurrentStep(initialStep);
    
  }, [authLoading, session, user]);

  // --- Authentication Check Effect ---
  useEffect(() => {
    // Don't run the check until authentication status is confirmed
    if (authLoading) return;

    // Check if user is unauthenticated AND on a protected step (2-7)
    if (!session && currentStep >= 2 && currentStep <= 8) {
      console.log(`Unauthenticated user trying to access step ${currentStep}. Redirecting to login.`);
      // Get the current path and query parameters
      const currentPath = window.location.pathname + window.location.search;
      // Construct the sign-in URL with the 'next' parameter
      const signInUrl = `/${locale}/auth/sign-in?next=${encodeURIComponent(currentPath)}`;
      // Redirect using router.replace to avoid adding the current (unauthorized) page to history
      router.replace(signInUrl);
    }
  }, [authLoading, session, currentStep, locale, router]);

  // Add useEffect to fetch recommendations when entering step 5
  useEffect(() => {
    if (currentStep === 5 && companyId && session) {
      console.log('Current step is 5, fetching funding recommendations for company:', companyId);
      fetchFundingRecommendations();
    }
  }, [currentStep, companyId, session]);

  // Add useEffect to fetch documents when the current step is 4 (NEW)
  useEffect(() => {
    // --- MODIFIED: Fetch documents in Step 4 --- 
    if (currentStep === 4 && companyId && session) {
      console.log('Current step is 4, fetching documents for company:', companyId);
      fetchDocuments();
    }
  }, [currentStep, companyId, session]); // Removed fetchDocuments from deps

  // --- ADDED: useEffect to handle entering Step 5 --- 
  useEffect(() => {
    if (currentStep === 5) {
      console.log('[Step 5 Entry] Ensuring isAnalyzing and isGeneratingRecommendations are false and fetching recommendations.');
      // Explicitly turn off loaders when entering Step 5 as a safeguard
      if (isAnalyzing) {
        setIsAnalyzing(false); 
      }
      if (isGeneratingRecommendations) {
        setIsGeneratingRecommendations(false);
      }
      // Fetch recommendations if needed
      if (companyId && session) {
         fetchFundingRecommendations();
      }
    }
  }, [currentStep, companyId, session, isAnalyzing, isGeneratingRecommendations]); // Added isAnalyzing dependency

  // Function to fetch user's company if it exists
  const fetchUserCompany = async () => {
    if (!session || !user) return;
    
    try {
      // Check if user profile has a company_id
      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('company_id')
        .eq('id', user.id)
        .single();
      
      if (profileError) {
        console.error('Error fetching user profile:', profileError);
        return;
      }
      
      if (profile && profile.company_id) {
        console.log('User has a company_id:', profile.company_id);
        setCompanyId(profile.company_id);
        
        // Fetch the company data
        const { data: company, error: companyError } = await supabase
          .from('companies')
          .select('*')
          .eq('id', profile.company_id)
          .single();
        
        if (companyError) {
          console.error('Error fetching company data:', companyError);
          return;
        }
        
        if (company) {
          console.log('Preloading company data:', company);
          
          // Set company data state
          setCompanyData(company);
          
          // Populate company form data
          setCompanyFormData({
            name: company.name || '',
            code: company.business_id || '',
            selectedCompany: null // We don't have the YTJ data structure here
          });
          
          // If company already has analysis, show it
          if (company.analysis_status === 'completed' && company.analysis_result) {
            setAnalysisResult(company.analysis_result);
          } else if (company.analysis_status === 'pending') {
            setIsAnalysisRunning(true);
          }
        }
      }
    } catch (error) {
      console.error('Error in fetchUserCompany:', error);
    }
  };

  // Debounced function for company search
  const debouncedCompanySearch = useCallback(
    debounce(async (query: string) => {
      if (query.length < 3) {
        setCompanySearchResults([]);
        setIsCompanySearchLoading(false);
        return;
      }
      setIsCompanySearchLoading(true);
      try {
        const response = await fetch(`/api/companies/search?query=${encodeURIComponent(query)}&limit=5`);
        const result = await response.json();
        if (result.success && result.data) {
          setCompanySearchResults(result.data);
        } else {
          setCompanySearchResults([]);
          console.error('Company search failed:', result.error);
        }
      } catch (error) {
        setCompanySearchResults([]);
        console.error('Error fetching company search:', error);
      } finally {
        setIsCompanySearchLoading(false);
      }
    }, 500), // 500ms debounce
    []
  );

  // Effect to trigger search when query changes
  useEffect(() => {
    debouncedCompanySearch(companySearchQuery);
  }, [companySearchQuery, debouncedCompanySearch]);

  // Handle company form changes
  const handleCompanyFormChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setCompanyFormData(prev => ({
      ...prev,
      [name]: value,
      // Clear selected company if name is manually changed
      selectedCompany: name === 'name' ? null : prev.selectedCompany,
    }));
    // If changing name, update search query
    if (name === 'name' && !companyFormData.selectedCompany) {
      setCompanySearchQuery(value);
    }
  };
  
  const handleCompanySelection = (selected: CompanySearchResult | null) => {
    if (selected) {
      setCompanyFormData({
        name: selected.name,
        code: selected.businessId,
        selectedCompany: selected,
      });
      setCompanySearchQuery(''); // Clear search query after selection
      setCompanySearchResults([]); // Clear results
    } else {
      // Handle case where selection is cleared (e.g., user deletes input)
       setCompanyFormData(prev => ({
         ...prev,
         selectedCompany: null,
       }));
    }
  };

  // Handle step 1 form submission - register and sign in user automatically
  const handleStep1Submit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setLoading(true);
    setError(null);

    // --- Added Consent Validation ---
    if (!initialFormData.consentAnalysis) {
      setError(t('error.consentAnalysisRequired', { default: 'You must consent to data analysis to proceed.' }));
      setLoading(false);
      return;
    }
    // --- End Consent Validation ---

    if (!turnstileToken) {
      setError(t('error.captcha', { default: 'Please complete the captcha verification' }));
      setLoading(false);
      return;
    }

    try {
      // Validate turnstile token
      const validateResponse = await fetch('/api/auth/validate-turnstile', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ token: turnstileToken }),
      });

      if (!validateResponse.ok) {
        throw new Error(t('error.captchaValidation', { default: 'Captcha validation failed' }));
      }

      // Generate a random temporary password
      const randomPassword = Math.random().toString(36).slice(-10) + 
                           Math.random().toString(36).toUpperCase().slice(-2) + '!1';

      // Sign up the user
      const { error: signUpError, data: signUpData } = await supabase.auth.signUp({
        email: initialFormData.email,
        password: randomPassword,
        options: {
          data: {
            // --- MODIFICATION: Use new fields and construct full_name ---
            first_name: initialFormData.firstName,
            last_name: initialFormData.lastName,
            phone_number: initialFormData.phone, // Use phone_number column name
            full_name: `${initialFormData.firstName} ${initialFormData.lastName}`, // Backward compatibility
            // --- END MODIFICATION ---
            username: initialFormData.email.split('@')[0] + Math.random().toString(36).substring(2, 7),
            email_verified: true,
          }
        }
      });

      // Handle case where user already exists (e.g., if they refreshed)
      if (signUpError && signUpError.message.includes('User already registered')) {
        // Attempt to sign in the existing user with a known temporary password pattern
        // or guide them to the sign-in page. For simplicity, let's just sign them in.
        const { data: { session: signedInSession, user: signedInUser }, error: signInError } = await supabase.auth.signInWithPassword({
          email: initialFormData.email,
          // Note: We don't know their *actual* password here if they exist and set one.
          // This might need a more robust check or flow if this is a common scenario.
          // For now, we assume if they hit this path, they are likely still in the initial flow.
          // A better approach might be to check if profile exists, and if so, redirect to sign-in.
          password: randomPassword, // This will fail if they set a real password
        });

        if (signInError) {
            console.warn('User already exists, sign-in attempt failed. Redirecting to sign-in.', signInError);
            // Redirect to sign-in page if temporary password login fails
            router.push(`/${locale}/auth/sign-in?email=${encodeURIComponent(initialFormData.email)}`);
            return;
        }

      } else if (signUpError) {
        // Throw any other sign-up errors
        throw signUpError;
      }

      // If sign up was successful OR sign-in after existing user check was successful:
      // Sign in the user automatically (needed even after signUp sometimes)
      const { data: { session: signedInSession, user: signedInUser }, error: signInError } = await supabase.auth.signInWithPassword({
        email: initialFormData.email,
        password: randomPassword, // Use the generated temporary password
      });

      if (signInError) throw signInError;

      // --- Save Consents AND Profile details ---
      if (signedInUser) {
        console.log(`User signed in/created: ${signedInUser.id}. Upserting profile...`);
        // --- DEBUG: Log state before upsert ---
        console.log('[DEBUG] handleStep1Submit - signedInUser.id:', signedInUser.id);
        console.log('[DEBUG] handleStep1Submit - initialFormData:', JSON.stringify(initialFormData, null, 2));
        // --- END DEBUG ---

        // --- STEP 1: Ensure profile row exists (Upsert MINIMUM required fields) ---
        // We need to provide values for any NOT NULL columns (like username, email, full_name)
        const generatedUsername = initialFormData.email.split('@')[0] + Math.random().toString(36).substring(2, 7);
        console.log('[DEBUG] Generated username:', generatedUsername);
        const constructedFullName = `${initialFormData.firstName} ${initialFormData.lastName}`.trim();
        console.log('[DEBUG] Constructed full_name:', constructedFullName);

        const { error: upsertError } = await supabase
          .from('profiles')
          .upsert(
            { 
              id: signedInUser.id,
              // --- FIX: Add required non-nullable fields ---
              username: generatedUsername,
              email: initialFormData.email,
              full_name: constructedFullName // Add full_name here
              // --- END FIX ---
            }, 
            { onConflict: 'id' } // Only specify conflict target, don't ignore other columns
          );

        if (upsertError) {
          console.error('Error ensuring profile row exists:', upsertError);
          // Decide if we should throw or continue to update attempt
          throw upsertError; // Throw for now, as update will likely fail
        }
        console.log('Profile row ensured (ID, Username, Email, FullName).');

        // --- STEP 2: Update remaining profile fields separately ---
        console.log('Attempting separate profile update for other fields...');
        const { error: updateError } = await supabase
          .from('profiles')
          .update({
            first_name: initialFormData.firstName,
            last_name: initialFormData.lastName,
            phone_number: initialFormData.phone || null,
            full_name: constructedFullName, 
            // --- FIX: Use correct column name for marketing consent --- 
            marketing_consent: initialFormData.consentMarketing,
            // Removed 'consents' object as the column doesn't exist
            // Removed analysis consent as there's no column for it
            // --- END FIX ---
            // No need to update email/username/full_name again here
          })
          .eq('id', signedInUser.id);

        if (updateError) {
          console.error('Error during separate profile update:', updateError);
          // Set error state, but maybe don't block navigation?
          setError(`Failed to update profile details: ${updateError.message}`);
          // Decide if you want to throw here or let the user proceed to step 2 anyway
          // throw updateError; 
        } else {
          console.log('Separate profile update successful.');
        }

      } // End if (signedInUser)
      // --- End Profile Save Logic ---

      goToStep(2);

    } catch (err) {
      console.error('Registration error:', err);
      setError(err instanceof Error ? err.message : t('error.register', { default: 'Registration failed. Please try again.' }));
    } finally {
      setLoading(false);
    }
  };

  // Add cleanup effect for realtime subscription when component unmounts
  useEffect(() => {
    return () => {
      // Clean up any active Supabase Realtime subscriptions when component unmounts
      if (realtimeChannel) {
        console.log('Cleaning up Realtime subscription on unmount');
        supabase.removeChannel(realtimeChannel).catch((err: Error) => {
          console.error('Error removing channel on unmount:', err);
        });
      }
    };
  }, [realtimeChannel]);

  // Add useEffect to fetch document types when the component mounts
  useEffect(() => {
    // Fetch document types when component mounts
    async function fetchDocumentTypes() {
      if (authLoading) return;
      
      setIsFetchingDocTypes(true); // Set loading state
      
      try {
        console.log('Fetching document types...');
        const { data, error } = await supabase
          .from('document_types')
          .select('*')
          .order('name');
          
        if (error) {
          console.error('Error fetching document types:', error);
          setError(t('error.fetchDocTypes', { default: 'Failed to fetch document types.' }));
          return;
        }
        
        if (data && data.length > 0) {
          console.log('Document types fetched:', data);
          setDocumentTypes(data);
        } else {
          // If no document types found, create default ones
          console.log('No document types found, using defaults');
          setDocumentTypes([
            {
              id: 'income_statement',
              name: 'income_statement',
              description: t('step3.incomeStatementDescription', { default: 'Income statement (tulos) from the last fiscal year' }),
              is_system_generated: false,
              required_for_analysis: true
            },
            {
              id: 'balance_sheet',
              name: 'balance_sheet',
              description: t('step3.balanceSheetDescription', { default: 'Balance sheet (tase) from the last fiscal year' }),
              is_system_generated: false,
              required_for_analysis: true
            },
            {
              id: 'recent_income_statement',
              name: 'recent_income_statement',
              description: t('step3.recentIncomeStatementDescription', { default: 'Most recent income statement draft (<2 months old)' }),
              is_system_generated: false,
              required_for_analysis: true
            },
            {
              id: 'recent_balance_sheet',
              name: 'recent_balance_sheet',
              description: t('step3.recentBalanceSheetDescription', { default: 'Most recent balance sheet draft (<2 months old)' }),
              is_system_generated: false,
              required_for_analysis: true
            }
          ]);
        }
      } catch (err) {
        console.error('Error in fetchDocumentTypes:', err);
        setError(t('error.fetchDocTypes', { default: 'Failed to fetch document types.' }));
      } finally {
        setIsFetchingDocTypes(false); // Clear loading state
      }
    }
    
    fetchDocumentTypes();
  }, [authLoading, supabase, t]);

  // --- Memoize fetchDocuments --- 
  const fetchDocuments = useCallback(async () => {
    if (!session?.access_token || !companyId) {
      console.log('No session access token or company ID for fetchDocuments');
      return;
    }

    try {
      console.log('Refreshing documents for company:', companyId);
      
      // Try to fetch using a server API endpoint that uses service role
      const response = await fetch(`/api/documents/list?companyId=${companyId}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${session?.access_token || ''}`
        }
      });
      
      if (!response.ok) {
        throw new Error(`API responded with status: ${response.status}`);
      }
      
      const apiData = await response.json();
      
      if (apiData.data && apiData.data.length > 0) {
        console.log('Processing API response data:', apiData.data);
        // The API already includes document_types, but using a different structure
        const processedDocuments = apiData.data.map((doc: any) => {
          return {
            ...doc,
            document_type: doc.document_types || null
          };
        });
        setDocuments(processedDocuments);
        
        // Extract financial data from processed documents
        const financialDoc = processedDocuments.find((doc: any) => 
          doc.processed && doc.extraction_data?.financial_data
        );
        
        if (financialDoc?.extraction_data?.financial_data) {
          const extractedData = financialDoc.extraction_data.financial_data;
          console.log('Found financial data in document:', extractedData);
          
          setFinancialDataArray([
            {
              revenue: extractedData.revenue || 0,
              profit: extractedData.profit || 0,
              assets: extractedData.assets || 0,
              liabilities: extractedData.liabilities || 0,
              equity: extractedData.equity || 0,
              fiscal_year: extractedData.fiscal_year || new Date().getFullYear(),
              fiscal_period: extractedData.fiscal_period || 'annual'
            }
          ]);
        }
      } else {
        console.log('No documents found via API');
        setDocuments([]);
      }
    } catch (err) {
      console.error('Error refreshing documents:', err);
    }
  }, [companyId, session]); // Removed setDocuments and setFinancialDataArray to prevent circular dependencies

  // --- Review fetchFinancialData dependencies --- 
  const fetchFinancialData = useCallback(async () => {
    if (currentStep !== 4) { 
      console.log('â„¹ï¸ [fetchFinancialData] Not on Step 4, skipping fetch.');
      return;
    }
    // Use session directly instead of session?.access_token as dependency if possible
    if (!companyId || !session) { // Check session existence
       console.log('â„¹ï¸ [fetchFinancialData] Missing companyId or session.');
       return;
    }

    console.log('ðŸ“Š Fetching ALL financial data years... (User is on Step 4)');
    setIsFetchingFinancials(true);

    try {
      // Refresh session inside the try block
      const { data: refreshData, error: refreshError } = await supabase.auth.refreshSession();
      if (refreshError || !refreshData?.session?.access_token) {
        console.error('âŒ Failed to refresh session or session invalid:', refreshError);
        throw new Error('Authentication session is invalid. Please sign in again.');
      }
      const refreshedToken = refreshData.session.access_token;

      // Corrected URL to use /list - REMOVED limit=1 to fetch all records
      const response = await fetch(`/api/financial-metrics/list?companyId=${companyId}&order=fiscal_year&direction=desc`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${refreshedToken}` // Use refreshed token
        }
      });

      if (response.ok) {
        const fetchedData = await response.json();
        console.log('âœ… Fetched ALL financial data years:', fetchedData);

        // Set the entire array of metrics, defaulting to empty array if none found
        const allMetrics = fetchedData.data || [];
        setFinancialDataArray(allMetrics);

        // Check if polling is active and if *any* fetched data meets the criteria to stop
        if (isPollingFinancials && allMetrics.length > 0) {
           // Example condition: stop polling if assets > 0 in the *latest* record
          const latestMetrics = allMetrics[0]; // Since it's sorted desc
          const assetsLoaded = latestMetrics?.total_fixed_assets !== null && latestMetrics?.total_fixed_assets !== undefined && parseFloat(latestMetrics.total_fixed_assets) > 0;
          if (assetsLoaded) {
            console.log('ðŸ›‘ Assets detected in latest record! Stopping polling.');
            setIsPollingFinancials(false);
            setSuccessMessage('Financial data updated successfully!'); // Update success message
          } else {
             console.log('â³ Assets not yet loaded in latest record, continuing polling...');
          }
        } else if (isPollingFinancials) {
            console.log('â³ No financial data returned yet, continuing polling...');
        }
      } else {
         // If fetch fails during polling, maybe stop polling or log and continue
         if (isPollingFinancials) {
            console.warn(`Polling fetch failed: ${response.status}`);
            // Optionally stop polling on fetch error:
            // setIsPollingFinancials(false);
            // setError('Failed to fetch updated financial data during polling.');
         }
         const errorText = await response.text();
         console.error(`âŒ Error fetching financial data: ${response.status}`, errorText);
         setFinancialDataArray([]); // Reset to empty array on error
      }
    } catch (error) { 
        // Also handle catch block during polling
        if (isPollingFinancials) {
            console.error('Polling fetch unexpected error:', error);
            // Optionally stop polling on fetch error:
            // setIsPollingFinancials(false);
            // setError('An unexpected error occurred during financial data polling.');
        }
        console.error('âŒ Unexpected error fetching financial data:', error);
        setFinancialDataArray([]); // Reset to empty array on error
    } finally {
       setIsFetchingFinancials(false); // Depends on setIsFetchingFinancials
    }
  }, [companyId, session, currentStep, isPollingFinancials, supabase.auth]); // Removed setter functions and circular dependencies

  // Function to handle document analysis triggering
  const handleAnalyzeAndContinue = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!companyId || !user) {
      setError(t('error.notAuthenticated', { default: 'Authentication required.' }));
      return;
    }
    // Prevent if initial trigger is happening (isAnalyzing) OR if background generation is already running
    if (isAnalyzing || isGeneratingRecommendations) return; 

    setError(null);
    setIsAnalyzing(true); // Set loading state for the button press/API call
    
    try {
      // Store the exact timestamp when analysis starts
      const currentTimestamp = Date.now();
      setAnalysisStartTimestamp(currentTimestamp);
      
      console.log(`ðŸš€ [Analysis] Triggering analysis via API route for company ${companyId}`);
      
      // First, ensure we have an active Realtime subscription
      if (!realtimeChannel) {
        console.warn('âš ï¸ [Analysis] No active Realtime channel detected. Re-establishing...');
        // The dependency array in the Realtime effect will re-establish the channel
        setRefetchTrigger(prev => prev + 1);
        
        // Small delay to allow subscription to establish
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
      if (!session?.access_token) {
          throw new Error('Access token is missing. Cannot trigger analysis.');
      }
      
      const response = await fetch('/api/onboarding/trigger-analysis', { 
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${session.access_token}`,
        },
        body: JSON.stringify({ 
          companyId: companyId, 
          locale: locale 
        }),
      });

      if (!response.ok) {        
        let errorMessage = `Failed to trigger analysis (Status: ${response.status})`;
        try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
        } catch (parseErr) {
            console.warn("Could not parse error response from /api/onboarding/trigger-analysis", parseErr);
        }
        throw new Error(errorMessage);
      }
      
      console.log('âœ… [Analysis] Trigger request sent successfully via API route.');
      
      // Update toast message to indicate we're proceeding to the summary page
      toast({
        title: t('step3.analysisStartedTitle', { default: 'Analysis Started' }),
        description: t('step3.analysisStartedDescription', { default: 'Document analysis and recommendation generation have been started. Proceeding to summary page.' }),
      });
      
      setIsGeneratingRecommendations(true); // Start the background generation loader state
      
      // MODIFICATION: Immediately navigate to the summary page instead of waiting
      goToStep(5);

      // Clear any success message that might have been set
      setSuccessMessage(null);

    } catch (err: any) {
      console.error('âŒ [Analysis] Error triggering analysis event:', err);
      setError(err.message || 'An unexpected error occurred while starting the analysis.');
      setIsGeneratingRecommendations(false);
    } finally {
      setIsAnalyzing(false); // Reset button-press state regardless of success/error
    }
  };

  // Render step indicator - Refactored for better styling and compactness
  const renderStepIndicator = () => (
    <div className="w-full px-4 sm:px-8">
      <nav className="flex items-center justify-center" aria-label="Progress">
        {steps.map((step, index) => (
          <React.Fragment key={step.title}>
            <div className="relative flex flex-col items-center">
              <div
                className={`flex h-8 w-8 items-center justify-center rounded-full border-2 transition-colors duration-300
                  ${currentStep === index + 1
                    ? 'border-gold-primary bg-black' // Active: Gold border, black background
                    : currentStep > index + 1
                      ? 'border-gold-primary bg-gold-primary' // Completed: Gold border and background
                      : 'border-gray-dark bg-gray-very-dark' // Inactive: Dark gray border and background
                  }
                  cursor-pointer hover:opacity-80
                `}
                onClick={() => goToStep(index + 1)}
                role="button"
                aria-label={`Go to step ${index + 1}: ${step.title}`}
                tabIndex={0}
              >
                {currentStep > index + 1 ? (
                  <CheckIcon className="h-5 w-5 text-black" aria-hidden="true" />
                ) : (
                  <span className={`font-medium text-sm ${currentStep === index + 1 ? 'text-gold-primary' : 'text-gray-dark'}`}>
                    {index + 1}
                  </span>
                )}
              </div>
              <span 
                className={`mt-2 text-xs font-medium text-center cursor-pointer hover:opacity-80 ${
                  currentStep === index + 1 ? 'text-gold-primary' :
                  currentStep > index + 1 ? 'text-gold-secondary' :
                  'text-gray-dark'
                }`}
                onClick={() => goToStep(index + 1)}
                role="button"
                aria-label={`Go to step ${index + 1}: ${step.title}`}
                tabIndex={0}
              >
                {step.title}
              </span>
            </div>
            
            {index < steps.length - 1 && (
              <div className={`flex-1 h-0.5 mx-4 transition-colors duration-300 ${
                currentStep > index + 1 ? 'bg-gold-primary' : 'bg-gray-dark'
              }`} />
            )}
          </React.Fragment>
        ))}
      </nav>
    </div>
  );

  // Update the step navigation functions to be more robust
  const goToStep = (step: number) => {
    // Allow navigation up to the maximum step (currently 7)
    if (step >= 1 && step <= 8) { 
      // Reset states only if moving *backwards* or to a significantly different flow? 
      // For now, keep resetting on any navigation for simplicity, but this could be refined.
      setLoading(false);
      setError(null);
      
      // Set the current step
      setCurrentStep(step);
      
      // Update URL to reflect current step (without reload)
      const url = new URL(window.location.href);
      url.searchParams.set('step', step.toString());
      window.history.replaceState({}, '', url.toString());
    }
  };

  // Add a function to handle continuing with existing company
  const continueWithExistingCompany = () => {
    console.log('[continueWithExistingCompany] Clicked. Company Data:', companyData);
    if (companyData) {
      // Create a synthetic form event
      const fakeEvent = { preventDefault: () => {} } as React.FormEvent<HTMLFormElement>;
      handleStep2Submit(fakeEvent);
    } else {
      console.log('[continueWithExistingCompany] Clicked but companyData is null.');
    }
  };

  // Render step 1 - Initial signup - Replaced with component call
  const renderStep1 = () => {
    // If user is already logged in, just show loading
    if (session && user && !authLoading) {
      return (
        <div className="flex justify-center items-center min-h-screen">
          <Spinner className="h-10 w-10 text-blue-600" />
          <p className="ml-3 text-lg text-gray-600">{t('redirecting', { default: 'Redirecting...' })}</p>
        </div>
      );
    }

    // Render the Step1Signup component with necessary props
    // --- MODIFICATION: Ensure props passed match Step1SignupProps exactly ---
    return (
      <Step1Signup
        initialFormData={{
          firstName: initialFormData.firstName,
          lastName: initialFormData.lastName,
          phone: initialFormData.phone,
          email: initialFormData.email,
          consentMarketing: initialFormData.consentMarketing,
          consentAnalysis: initialFormData.consentAnalysis,
        }}
        loading={loading}
        error={error}
        turnstileToken={turnstileToken}
        locale={locale as string}
        handleInitialFormChange={handleInitialFormChange} // Pass the single, correct handler
        handleCheckboxChange={handleCheckboxChange} // Pass the single, correct handler
        handleStep1Submit={handleStep1Submit}
        setTurnstileToken={setTurnstileToken}
        setError={setError}
      />
    );
    // --- END MODIFICATION ---
  };

  // Render step 2 - Company Info - Refactored to use the component directly
  const renderStep2 = () => (
    <Step2CompanyInfo
      companyFormData={companyFormData}
      companySearchQuery={companySearchQuery}
      companySearchResults={companySearchResults}
      isCompanySearchLoading={isCompanySearchLoading}
      companyData={companyData}
      isAnalysisRunning={isAnalysisRunning}
      loading={loading}
      error={error}
      handleCompanyFormChange={handleCompanyFormChange}
      handleCompanySelection={handleCompanySelection}
      handleStep2Submit={handleStep2Submit}
      continueWithExistingCompany={continueWithExistingCompany}
      setCompanyData={setCompanyData}
      setCompanyId={setCompanyId}
      setCompanyFormData={setCompanyFormData}
      setCompanySearchQuery={setCompanySearchQuery}
    />
  );

  // Render step 3 - NEW: Preliminary Analysis
  const renderStep3 = () => (
    <Step3PreAnalysis
      loading={loading}
      error={error}
      companyData={companyData}
      companyId={companyId}
      onContinue={() => goToStep(4)} // Go to the next step (Funding Needs)
      isAnalysisRunning={isAnalysisRunning}
      analysisResult={analysisResult}
    />
  );

  // Render step 4 - Funding Needs (was step 3)
  const renderStep4 = () => (
    <Step4FundingNeeds
      loading={loading}
      error={error}
      fundingFormData={fundingFormData}
      setFundingFormData={setFundingFormData}
      handleSubmit={handleStep4Submit}
      companyData={companyData}
      companyId={companyId}
    />
  );

  // Render step 5 - Document Upload (was step 4)
  const renderStep5 = () => (
    <Step5DocumentUpload
      loading={loading}
      error={error}
      uploading={uploading}
      documents={documents}
      documentTypes={documentTypes}
      isDragging={isDragging}
      setIsDragging={setIsDragging}
      handleFileUpload={handleFileUpload}
      setUploadedFiles={setUploadedFiles}
      fetchDocuments={fetchDocuments}
      handleAnalyzeAndContinue={handleAnalyzeAndContinue}
      isGeneratingRecommendations={isGeneratingRecommendations}
      isAnalyzing={isAnalyzing}
      financialDataArray={financialDataArray}
      isFetchingFinancials={isFetchingFinancials}
      companyId={companyId}
      currentLocale={locale as string}
    />
  );

  // Render step 6 - Summary (was step 5)
  const renderStep6 = () => {
    // We're coming from document upload if analysis was triggered recently
    const isFromStep4 = true; // Always set to true when rendering Step 6 directly after analysis
    
    return (
      <Step6Summary
        companyName={companyData?.name || companyFormData.name || 'Your Company'}
        fundingRecommendations={fundingRecommendations}
        isFetchingRecommendations={isFetchingRecommendations}
        error={error}
        goToStep={goToStep}
        goToDashboard={() => router.push(`/${locale}/dashboard`)}
        startApplication={(recommendationId, fundingCategory) => {
          // Pre-fill recommendation ID if provided
          setApplicationFormData(prev => ({ ...prev, funding_recommendation_id: recommendationId || null }));
          // Set the funding type if provided, otherwise default to business_loan
          setFundingType(fundingCategory || 'business_loan');
          goToStep(7); // Changed from 6 to 7 since we added a new step
        }}
        companyId={companyId}
        userCompanies={userCompanies}
        handleCompanyChange={handleCompanyChange}
        isFetchingCompanies={isFetchingCompanies}
        locale={locale as string} // Pass locale
        analysisStartTime={analysisStartTimestamp} // Pass the stored timestamp
      />
    );
  };

  // NEW: Render step 7 - Application (was step 6)
  const renderStep7 = () => (
    <Step7Application
      loading={loading}
      error={error}
      applicationFormData={applicationFormData}
      handleApplicationFormChange={handleApplicationFormChange}
      handleTermSliderChange={handleTermSliderChange}
      handleSubmit={handleStep7Submit}
      companyData={companyData}
      fundingType={fundingType}
      handleFundingTypeChange={handleFundingTypeChange}
      fundingFormData={fundingFormData}
      selectedRecommendation={selectedRecommendation}
    />
  );

  // NEW: Render Step 8 - KYC / UBO (was Step 7)
  const renderStep8 = () => {
    // ... existing code ...
    return (
      <Step8KycUbo
        loading={loading}
        error={error}
        applicantNationalId={kycUboFormData.applicantNationalId}
        setApplicantNationalId={(id) => setKycUboFormData(prev => ({...prev, applicantNationalId: id}))}
        ubos={kycUboFormData.ubos}
        setUbos={(newUbos) => setKycUboFormData(prev => ({...prev, ubos: newUbos}))}
        applicationId={applicationId}
        goToStep={goToStep}
        companyId={companyId}
        applicationFormData={applicationFormData}
        fundingFormData={fundingFormData}
        setError={setError}
        setLoading={setLoading}
        documents={documents}
        documentTypes={documentTypes}
        fetchDocuments={fetchDocuments}
        handleFileUpload={handleFileUpload}
        uploading={uploading}
        isDragging={isDragging}
        setIsDragging={setIsDragging}
        setUploadedFiles={setUploadedFiles}
        currentLocale={locale as string}
      />
    );
  };

  // Restore renderCurrentStep function
  const renderCurrentStep = () => {
    switch (currentStep) {
      case 1:
        return renderStep1();
      case 2:
        return renderStep2();
      case 3: // NEW: Preliminary Analysis
        return renderStep3();
      case 4: // Step 4 (Funding Needs, was Step 3)
        return renderStep4();
      case 5: // Step 5 (Document Upload, was Step 4)
        return renderStep5();
      case 6: // Step 6 (Summary, was Step 5)
        return renderStep6();
      case 7: // Step 7 (Application, was Step 6)
        return renderStep7();
      case 8: // Step 8 (KYC/UBO, was Step 7)
        return renderStep8();
      default:
        return <div>Invalid step</div>;
    }
  };

  // Render step 4 - Document upload (NEW) - using the renamed component
  const renderStep4 = () => (
    <Step4DocumentUpload // Renamed component
      documents={documents}
      documentTypes={documentTypes}
      financialDataArray={financialDataArray} // Pass the array
      isFetchingFinancials={isFetchingFinancials}
      uploading={uploading}
      loading={loading} // Pass general loading
      error={error}
      isDragging={isDragging}
      setIsDragging={setIsDragging}
      handleFileSelect={handleFileSelect}
      handleFileUpload={handleFileUpload}
      fetchDocuments={fetchDocuments}
      // --- MODIFIED: Pass handleAnalyzeAndContinue for the analysis trigger ---
      handleAnalyzeAndContinue={handleAnalyzeAndContinue}
      isAnalyzing={isAnalyzing} // Pass analysis specific loading state
      // --- END MODIFIED ---
      goToStep={goToStep}
      supabase={supabase}
      setError={setError}
      setUploadedFiles={setUploadedFiles}
      companyId={companyId}
      userCompanies={userCompanies}
      handleCompanyChange={handleCompanyChange}
      isFetchingCompanies={isFetchingCompanies}
      isGeneratingRecommendations={isGeneratingRecommendations} // Pass state down
      setIsGeneratingRecommendations={setIsGeneratingRecommendations} // Pass setter down
      currentLocale={locale as string} // Pass the current locale
      setLoading={setLoading}
      session={session}
    />
  );

  // Render step 5 - Summary & Recommendations
  const renderStep5 = () => {
    // We're coming from document upload if analysis was triggered recently
    const isFromStep4 = true; // Always set to true when rendering Step 5 directly after analysis
    
    return (
      <Step5Summary
        companyName={companyData?.name || companyFormData.name || 'Your Company'}
        fundingRecommendations={fundingRecommendations}
        isFetchingRecommendations={isFetchingRecommendations}
        error={error}
        goToStep={goToStep}
        goToDashboard={() => router.push(`/${locale}/dashboard`)}
        startApplication={(recommendationId, fundingCategory) => {
          // Pre-fill recommendation ID if provided
          setApplicationFormData(prev => ({ ...prev, funding_recommendation_id: recommendationId || null }));
          // Set the funding type if provided, otherwise default to business_loan
          setFundingType(fundingCategory || 'business_loan');
          goToStep(6);
        }}
        companyId={companyId}
        userCompanies={userCompanies}
        handleCompanyChange={handleCompanyChange}
        isFetchingCompanies={isFetchingCompanies}
        locale={locale as string} // Pass locale
        analysisStartTime={analysisStartTimestamp} // Pass the stored timestamp
      />
    );
  };

  // --- ADD Handler for Step 6 Funding Type ---
  const handleFundingTypeChange = (value: string) => {
    console.log("Funding type changed to:", value);
    setFundingType(value);
    // Optionally clear validation error when type is selected
    if (value) {
      setError(null); 
    }
  };
  // --- END ADD Handler ---

  // Render step 6 - Application Details
  const renderStep6 = () => (
    <Step6Application
      applicationFormData={applicationFormData}
      fundingType={fundingType}
      handleFundingTypeChange={handleFundingTypeChange}
      handleApplicationFormChange={handleApplicationFormChange}
      handleTermSliderChange={handleTermSliderChange}
      onSubmit={handleSaveDraftApplication} // Pass the new handler here
      goToStep={goToStep}
      loading={loading}
      error={error}
      companyId={companyId}
      userCompanies={userCompanies}
      handleCompanyChange={handleCompanyChange}
      isFetchingCompanies={isFetchingCompanies}
      // Pass factoring data from Step 4 state (if available)
      factoringMonthlyInvoices={fundingFormData.factoring_monthlyInvoices?.toString()} 
      factoringPaymentDays={fundingFormData.factoring_paymentDays?.toString()}
      factoringCustomerLocation={fundingFormData.factoring_customerLocation}
    />
  );

  // --- Render Step 7 - KYC / UBO ---
  const renderStep7 = () => {
    // Ensure companyId and applicationId are potentially available before rendering
    // Add loading state check if needed based on UX requirements
    // if (loading && !applicationId) return <Spinner />; // Example loading indicator

    // --- CORRECTED Props passed to Step7KycUbo ---
    return (
      <Step7KycUbo
        loading={loading} // Pass overall loading state
        error={error} // Pass error state
        // Pass state & setters for KYC/UBO data (assuming managed in OnboardingFlow)
        // If these are managed internally within Step7, they might not be needed here.
        // Check Step7KycUbo internal state management.
        applicantNationalId={kycUboFormData.applicantNationalId} // Assuming kycUboFormData state exists
        setApplicantNationalId={(id) => setKycUboFormData(prev => ({...prev, applicantNationalId: id}))} // Assuming setter exists
        ubos={kycUboFormData.ubos} // Assuming kycUboFormData state exists
        setUbos={(newUbos) => setKycUboFormData(prev => ({...prev, ubos: newUbos}))} // Assuming setter exists
        // REMOVED: applicationSummaryData prop - Step7 will fetch its own summary data
        applicationId={applicationId} // Pass the potentially fetched applicationId state
        goToStep={goToStep} // Pass navigation function
        companyId={companyId} // Pass current company ID
        applicationFormData={applicationFormData} // Pass Step 6 form data
        fundingFormData={fundingFormData} // Pass Step 4 form data
        setError={setError} // Pass error setter
        setLoading={setLoading} // Pass loading setter
        // REMOVED: onFinalSubmit prop as it's handled internally in Step7
        // --- ADDED: Document Management Props ---
        documents={documents}
        documentTypes={documentTypes}
        fetchDocuments={fetchDocuments}
        handleFileUpload={handleFileUpload}
        uploading={uploading}
        isDragging={isDragging}
        setIsDragging={setIsDragging}
        setUploadedFiles={setUploadedFiles}
        currentLocale={locale as string}
        // --- END: Document Management Props ---
      />
    );
  };

  // Restore renderCurrentStep function
  const renderCurrentStep = () => {
    switch (currentStep) {
      case 1:
        return renderStep1();
      case 2:
        return renderStep2();
      case 3: // Render NEW Step 3 (Funding Needs)
        return renderStep3();
      case 4: // Render NEW Step 4 (Document Upload)
        return renderStep4();
      case 5:
        return renderStep5();
      case 6:
        return renderStep6();
      case 7:
        return renderStep7();
      default:
        return <div>Invalid step</div>;
    }
  };

  // Restore and update handleStep4Submit function
  const handleStep3Submit = async (questionnaireData: any) => {
    console.log("Received Questionnaire Data in OnboardingFlow (New Step 3):", questionnaireData);

    if (!session || !companyId) {
      setError(t('error.notAuthenticated', { default: 'Authentication session or Company ID missing. Please sign in again or select a company.' }));
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Call API to save financing needs
      const response = await fetch('/api/financing-needs', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
        'Authorization': `Bearer ${session.access_token}`,
      },
      body: JSON.stringify({
        companyId,
        userId: session.user.id,
        questionnaire: questionnaireData
      }),
    });

    if (!response.ok) {
      let errorMsg = 'Failed to submit financing needs';
      try {
        const errorBody = await response.json();
        errorMsg = errorBody.error || errorMsg;
      } catch (parseError) { /* Ignore */ }
      throw new Error(errorMsg);
    }

    const data = await response.json();
    console.log('Financing needs submitted successfully:', data);

    // Store the returned financingNeedsId
    if (data.financingNeedsId) {
      setFinancingNeedsId(data.financingNeedsId);
      console.log('Stored financingNeedsId:', data.financingNeedsId);
    } else {
      console.warn('API response did not include financingNeedsId');
      // Consider setting an error or handling this missing ID case
    }

    toast({
      title: t('step4.stage6.successTitle', { default: 'Information Submitted'}),
      description: t('step4.stage6.successDescription', { default: 'Your funding needs questionnaire has been saved.'}),
    });

    // --- MODIFIED: Go to NEW Step 4 (Document Upload) ---
    goToStep(4);

  } catch (err) {
    console.error('Error submitting step 3 (Funding Needs):', err);
    const errorMessage = err instanceof Error ? err.message : 'An unexpected error occurred';
    setError(errorMessage);
    toast({
      variant: 'destructive',
      title: t('error.genericTitle', { default: 'Submission Error'}),
      description: errorMessage,
    });
  } finally {
    setLoading(false);
  }
  };

  // Handler for Step 6 application form data change
  const handleApplicationFormChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setApplicationFormData(prev => ({
      ...prev,
      // Convert to number if the input is numeric, otherwise keep as string
      [name]: (name === 'amount' || name === 'term_months') && /^\d*\.?\d*$/.test(value) && value !== ''
              ? Number(value)
              : value
    }));
  };

  // --- Handler for Step 6 Term Slider --- 
  const handleTermSliderChange = (value: number[]) => {
    // Slider typically returns an array, take the first element
    const term = value[0];
    setApplicationFormData(prev => ({
      ...prev,
      term_months: term
    }));
  };

  // Handler for Step 7 form submission - RENAMED/REFACTORED to handleFinalApplicationSubmit
  const handleFinalApplicationSubmit = async () => {
    // No event needed if triggered by button onClick
    // e.preventDefault(); 

    // --- Basic Validation --- (Should match Step7KycUbo validation)
    if (!kycUboFormData.applicantNationalId.trim()) {
      setError(t('step7.error.applicantIdRequired', { default: "Applicant's National ID is required." }));
      return;
    }
    const invalidUbo = kycUboFormData.ubos.find(ubo => 
        !ubo.nationalId.trim() || !ubo.firstName.trim() || !ubo.lastName.trim()
    );
    if (invalidUbo) {
        setError(t('step7.error.uboFieldsRequired', { default: "All fields are required for each listed beneficial owner." }));
        return;
    }
    // --- End Basic Validation ---

    if (!session || !companyId) {
      setError(t('error.notAuthenticated', { default: 'Session or Company ID missing.' }));
      return;
    }

    setLoading(true);
    setError(null);

    // --- Gather ALL data for submission ---
    const finalPayload = {
      // From Step 2/Company Data
      company_id: companyId,
      // From Step 4 (assuming structure)
      financing_needs_details: fundingFormData, // Pass the whole object or specific fields
      // From Step 6
      amount: Number(applicationFormData.amount),
      term_months: Number(applicationFormData.term_months),
      funding_recommendation_id: applicationFormData.funding_recommendation_id,
      // From Step 7 (TEMPORARY DATA - DO NOT SAVE TO DB PERMANENTLY)
      applicant_national_id: kycUboFormData.applicantNationalId,
      ubo_list: kycUboFormData.ubos.map(({ id, ...rest }) => rest), // Remove temporary client ID
      // Other relevant data
      user_id: session.user.id,
    };

    console.log('Submitting final application payload:', {
      ...finalPayload,
      applicant_national_id: '[REDACTED]', // Avoid logging sensitive data
      ubo_list: '[REDACTED]' 
    });

    try {
      // Call the backend endpoint (ensure it handles the new payload)
      const response = await fetch('/api/funding-applications', { // Or a new endpoint if needed
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${session.access_token}`,
        },
        body: JSON.stringify(finalPayload),
      });

      if (!response.ok) {
        let errorData;
        try {
          errorData = await response.json();
        } catch (parseError) {
          errorData = { error: `Request failed with status ${response.status}` };
        }
        throw new Error(errorData.error || 'Failed to submit application.');
      }

      const result = await response.json();
      console.log('Funding application submitted successfully:', result);
      
      // Show success toast instead of redirecting
      toast({
        title: t('step7.finalSuccessPopupTitle'), 
        description: t('step7.finalSuccessPopupDescription'),
        duration: 9000, // Keep it visible a bit longer
        action: (
          <Button 
            variant="outline" // Or your preferred style for toast actions
            size="sm" 
            onClick={() => router.push(`/${locale}/dashboard`)}
            className="ml-auto border-amber-300 text-amber-300 hover:bg-amber-300/10"
          >
            {t('step7.finalSuccessPopupAction')}
          </Button>
        ),
      });

      // Remove the immediate redirect
      // router.push(`/${locale}/dashboard`);

    } catch (err) {
      console.error('Error submitting final funding application:', err);
      setError(err instanceof Error ? err.message : 'An unexpected error occurred.');
      toast({
        variant: 'destructive',
        title: t('error.genericTitle'),
        description: err instanceof Error ? err.message : t('error.generic'),
      });
    } finally {
      // --- CRUCIAL: Clear sensitive data from state --- 
      setKycUboFormData({ applicantNationalId: '', ubos: [] });
      console.log('Cleared sensitive KYC/UBO data from state.');
      // --- End Clear sensitive data --- 
      setLoading(false);
    }
  };

  // --- Fetch USER COMPANIES list ---
  const fetchUserCompanies = async () => {
    if (!session || !user) return;
    
    setIsFetchingCompanies(true);
    setUserCompanies([]); // Clear previous list
    setCompanyId(null); // Reset selected company
    setCompanyData(null); // Reset selected company data
    
    try {
      // Fetch companies created by the user (adjust query if association logic differs)
      const { data: companies, error: companiesError } = await supabase
        .from('companies')
        .select('id, name, business_id') // Fetch needed fields
        .eq('created_by', user.id) // Assuming created_by links companies to users
        .order('name'); // Order alphabetically

      if (companiesError) {
        console.error('Error fetching user companies:', companiesError);
        setError(t('error.fetchCompanies', { default: 'Failed to load your companies.' }));
        setUserCompanies([]);
        return;
      }

      if (companies && companies.length > 0) {
        console.log('User companies fetched:', companies);
        setUserCompanies(companies);
        
        // --- Select the first company by default --- 
        // (Or implement logic to select based on profile.company_id or last used)
        const initialCompany = companies[0];
        setCompanyId(initialCompany.id);
        // Fetch full data for the initially selected company
        await fetchSelectedCompanyData(initialCompany.id);
        
      } else {
        console.log('No companies found for this user.');
        setUserCompanies([]);
        // If no companies, user needs to create one in Step 2
        // No need to set companyId or companyData
      }
    } catch (error) {
      console.error('Error in fetchUserCompanies:', error);
      setError(t('error.fetchCompanies', { default: 'An unexpected error occurred while loading companies.' }));
      setUserCompanies([]);
    } finally {
      setIsFetchingCompanies(false);
    }
  };
  
  // --- Fetch FUNDING RECOMMENDATIONS ---
  const fetchFundingRecommendations = useCallback(async () => {
    if (!companyId || !session) return;
    
    console.log(`ðŸ” [OnboardingFlow] Fetching funding recommendations for company ${companyId}`);
    setIsFetchingRecommendations(true);
    
    try {
      // Fetch recommendations with explicit retry mechanism
      let retryCount = 0;
      const MAX_RETRIES = 2;
      let recommendations = null;
      let error = null;
      
      while (retryCount <= MAX_RETRIES && !recommendations) {
        if (retryCount > 0) {
          console.log(`ðŸ”„ [OnboardingFlow] Retry ${retryCount}/${MAX_RETRIES} fetching recommendations`);
        }
        
        try {
          const result = await supabase
            .from('funding_recommendations')
            .select('*')
            .eq('company_id', companyId)
            .order('created_at', { ascending: false });
            
          if (result.error) {
            error = result.error;
            console.error(`âŒ [OnboardingFlow] Error fetching recommendations (try ${retryCount}):`, error);
          } else {
            recommendations = result.data;
            console.log(`âœ… [OnboardingFlow] Successfully fetched ${recommendations?.length || 0} recommendations`);
          }
        } catch (err) {
          error = err;
          console.error(`âŒ [OnboardingFlow] Exception fetching recommendations (try ${retryCount}):`, err);
        }
        
        if (!recommendations && retryCount < MAX_RETRIES) {
          // Wait before retrying
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        retryCount++;
      }
      
      if (recommendations && recommendations.length > 0) {
        setFundingRecommendations(recommendations);
        // Turn off the generating indicator when we have recommendations
        setIsGeneratingRecommendations(false);
        return true;
      } else if (error) {
        const errorObj = { message: error.message || 'Unknown error' };
        setError(`${t('step5.errorLoadingRecommendations', { default: 'Failed to load recommendations:' })} ${errorObj.message}`);
        return false;
      } else {
        console.log('â„¹ï¸ [OnboardingFlow] No recommendations found for company');
        setFundingRecommendations([]);
        return false;
      }
    } catch (err) {
      console.error('âŒ [OnboardingFlow] Unexpected error in fetchFundingRecommendations:', err);
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setError(`${t('step5.errorLoadingRecommendations', { default: 'Failed to load recommendations:' })} ${errorMessage}`);
      return false;
    } finally {
      setIsFetchingRecommendations(false);
    }
  }, [companyId, session, t, supabase]);

  // --- ADDED: Memoize fetchSelectedCompanyData to stabilize useEffect dependency ---
  const fetchSelectedCompanyData = useCallback(async (selectedCompanyId: string | null): Promise<CompanyRow | null> => {
    if (!selectedCompanyId || !supabase) {
      console.log('â„¹ï¸ [fetchSelectedCompanyData] No company ID or Supabase client, returning null.');
      return null;
    }
    console.log(`ðŸ” [fetchSelectedCompanyData] Fetching data for company ID: ${selectedCompanyId}`);
    try {
      const { data, error } = await supabase
        .from('companies')
        .select('*') // Select specific columns if needed
        .eq('id', selectedCompanyId)
        .single();

      if (error) {
        console.error(`âŒ [fetchSelectedCompanyData] Error fetching company data for ${selectedCompanyId}:`, error);
        // Don't throw here, return null to let the caller handle it
        return null;
      }

      console.log(`âœ… [fetchSelectedCompanyData] Successfully fetched data for company ID: ${selectedCompanyId}`);
      return data as CompanyRow; // Cast might be needed depending on your exact CompanyRow type
    } catch (err: any) {
      console.error(`âŒ [fetchSelectedCompanyData] Unexpected error for company ID ${selectedCompanyId}:`, err);
      return null; // Return null on unexpected errors too
    }
  }, [supabase]); // Dependency: supabase client instance

  // --- Add useEffect to re-fetch data when companyId changes --- 
  useEffect(() => {
    if (companyId && session) {
        // Fetch data relevant to the selected company
        console.log(`Company changed to ${companyId}. Refetching relevant data.`);
        fetchSelectedCompanyData(companyId); // Fetch full data for the selected company

        // Reset step-specific data that depends on the company
        setDocuments([]); // Clear documents list for Step 3
        setFinancialDataArray([]); // Clear financial summary array for Step 3
        setFundingRecommendations([]); // Clear recommendations for Step 5
        setApplicationFormData({ amount: '', term_months: '', funding_recommendation_id: null }); // Reset application form for Step 6

        // Trigger fetches for the current step if it depends on companyId
        // --- MODIFIED: Fetch documents in Step 4 ---
        if (currentStep === 4) {
          fetchDocuments();
        }
        // --- END MODIFIED ---
        if (currentStep === 5) {
            fetchFundingRecommendations();
        }
        // --- Fetch financing needs amount when entering Step 6 ---
        if (currentStep === 6) {
          fetchFinancingNeedsAmount(); // Call the new fetch function
        }
        // Add fetches for other steps if necessary
    }
  }, [companyId, session, currentStep, fetchSelectedCompanyData, fetchFundingRecommendations]); // Added currentStep dependency

  // --- Handler for Company Selection Change ---
  const handleCompanyChange = (newCompanyId: string) => {
    if (newCompanyId !== companyId) {
        console.log(`User selected new company: ${newCompanyId}`);
        setError(null); // Clear errors when switching company
        setCompanyId(newCompanyId); // This will trigger the useEffect above to fetch/reset data
    } 
  };

  // Get document type name safely
  const getDocumentTypeName = (doc: any) => {
    if (doc.document_type?.name) {
      return doc.document_type.name.replace(/_/g, ' ').replace(/\b\w/g, (c: string) => c.toUpperCase());
    }
    return 'â€”';
  };

  // Once the component mounts and we have a companyId, fetch financial data
  useEffect(() => {
    if (companyId && session?.access_token && currentStep === 4) { // <-- Changed from 3 to 4
      console.log('Fetching initial financial data on mount (Step 4)');
      fetchFinancialData();
    }
  }, [companyId, session?.access_token, currentStep]);

  // Function to store financial metrics from company data
  const storeFinancialMetrics = async (companyData: any) => {
    if (!companyData?.id || !session?.user?.id) {
      console.error('Cannot store financial metrics: missing company ID or user ID');
      return;
    }
    
    if (!session?.access_token) {
      console.error('Cannot store financial metrics: missing access token');
      return;
    }
    
    console.log('Processing company data for financial metrics:', companyData.id);
    console.log('Using auth token:', session.access_token.substring(0, 10) + '...');
    
    const yearlyFinancials = companyData?.metadata?.financial_data?.yearly;
    
    if (yearlyFinancials && Array.isArray(yearlyFinancials) && yearlyFinancials.length > 0) {
      try {
        console.log('Processing financial data from company metadata:', yearlyFinancials);
        
        for (const yearData of yearlyFinancials) {
          const parseIfNumeric = (value: any): number | null => {
            if (typeof value === 'number') return isFinite(value) ? value : null;
            if (typeof value !== 'string' || value.trim() === '' || value.toLowerCase() === 'not available') return null;
            // Use the robust parsing logic
            let cleanedValue = value.replace(',', '.');
            cleanedValue = cleanedValue.replace(/\s/g, ''); 
            cleanedValue = cleanedValue.replace(/[^\d.-]/g, '');
            const parsed = parseFloat(cleanedValue);
            return !isNaN(parsed) && isFinite(parsed) ? parsed : null;
          };
          
          const fiscalYear = yearData.year ? parseInt(yearData.year) : null;

          if (!fiscalYear) {
              console.warn(`Skipping metadata financial data with missing/invalid year: ${JSON.stringify(yearData)}`);
            continue;
          }
          
          // Extract and map known fields from enrichment data
          const metricsPayload = {
            company_id: companyData.id,
            fiscal_year: fiscalYear,
            fiscal_period: yearData.fiscal_period || 'annual', // Assuming enrichment provides period, else default
            
            // Map standard fields
            revenue: parseIfNumeric(yearData.revenue),
            net_profit: parseIfNumeric(yearData.profit), // Map enrichment 'profit' to 'net_profit'
            
            // Map potential additional fields (add others if enrichment provides them)
            operating_profit: parseIfNumeric(yearData.operating_profit ?? yearData.liiketulos), // Check for common names
            ebitda: parseIfNumeric(yearData.ebitda ?? yearData.kayttokate), // Check for common names
            total_assets: parseIfNumeric(yearData.total_assets ?? yearData.assets),
            total_liabilities: parseIfNumeric(yearData.total_liabilities ?? yearData.liabilities),
            total_equity: parseIfNumeric(yearData.total_equity ?? yearData.equity),
            // Add more mappings here if the enrichment step consistently provides other fields
            
            source_document_ids: [], // Not applicable for metadata source
            created_by: session.user.id,
            data_source: 'company_metadata' // Mark source
          };
          
          // Clean the payload: remove null/undefined values before sending
          const cleanedPayload: { [key: string]: any } = {};
          for (const key in metricsPayload) {
            if (metricsPayload[key as keyof typeof metricsPayload] !== null && 
                metricsPayload[key as keyof typeof metricsPayload] !== undefined) {
                cleanedPayload[key] = metricsPayload[key as keyof typeof metricsPayload];
            }
          }

          // Check if there's anything to save besides metadata keys
          const dataKeys = Object.keys(cleanedPayload).filter(k => !['company_id', 'fiscal_year', 'fiscal_period', 'source_document_ids', 'created_by', 'data_source'].includes(k));
          if (dataKeys.length === 0) {
             console.log(`No numeric financial data found in metadata for year ${fiscalYear}. Skipping storage.`);
             continue;
          }

          try {
            console.log(`Storing metadata financial data for year ${yearData.year}:`, cleanedPayload);
            const response = await fetch('/api/financial-data', {
            method: 'POST',
              headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${session.access_token}` },
              body: JSON.stringify(cleanedPayload) // Send the cleaned payload
            });
            
            if (response.ok) {
              const result = await response.json();
              console.log(`Successfully stored metadata financial data for year ${yearData.year}:`, result.id);
            } else {
              const errorText = await response.text();
              console.error(`Failed to store metadata financial data for year ${yearData.year}:`, { status: response.status, statusText: response.statusText, body: errorText });
            }
        } catch (error) {
            console.error(`Error POSTing metadata financial data for year ${yearData.year}:`, error);
          }
        }
      } catch (error) {
        console.error('Error processing financial data from metadata:', error);
      }
    } else {
      console.log('No financial data found in company metadata (metadata.financial_data.yearly)');
    }
  };

  // Fetch financial data effect
  useEffect(() => {
    if (companyId && session?.access_token) {
       fetchFinancialData();
    }
  }, [companyId, session?.access_token, fetchFinancialData]);

  // --- ADDED: Supabase Realtime subscription for document updates --- --- REMOVED: currentStep check from the main condition --- 
  useEffect(() => {
    // Ensure supabase client and companyId are available
    if (!supabase || !companyId) {
      // Cleanup if missing dependencies
      if (realtimeChannel) {
          console.log(`Removing Realtime subscription for company ${companyId || 'N/A'} (missing deps)`);
          // Fix linter error here by typing err
          supabase.removeChannel(realtimeChannel).catch((err: any) => {
            console.error('Error removing realtime channel during cleanup:', err);
          });
          setRealtimeChannel(null); // Clear state
      }
      return;
    }

    // --- Setup Realtime if deps are valid --- 
    // Check if a channel for this company already exists to prevent duplicates
    if (realtimeChannel && realtimeChannel.topic === `realtime:public:documents:company_id=eq.${companyId}`) {
        console.log(`Realtime subscription already active for company ${companyId}. Skipping setup.`);
        return;
    }
    
    // If a different channel exists, remove it first
    if (realtimeChannel) {
      console.log(`Removing OLD Realtime subscription (${realtimeChannel.topic}) before creating new one.`);
       // Fix linter error here by typing err
      supabase.removeChannel(realtimeChannel).catch((err: any) => console.error('Error removing OLD channel:', err));
    }

    console.log(`Setting up Realtime subscription for documents, companyId: ${companyId}`);

    let channel: RealtimeChannel | null = null;

    channel = supabase.channel(`documents-company-${companyId}`)
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'documents',
          filter: `company_id=eq.${companyId}`
        },
        (payload: RealtimePostgresChangesPayload<{ [key: string]: any }>) => {
          // --- Type Guard for payload.new ---
          if (typeof payload.new !== 'object' || payload.new === null) {
            console.warn('Realtime: Received non-object payload.new', payload);
            return; // Ignore invalid payloads
          }
          const newDocData = payload.new as { id?: string, processing_status?: string, [key: string]: any }; // Type assertion

          console.log('Realtime: Document updated received:', newDocData.id, newDocData.processing_status);
          
          // Check if ID exists before proceeding
          if (!newDocData.id) {
            console.warn('Realtime: Received payload without an ID. Fetching full list as fallback.');
            fetchDocuments();
            return;
          }

          // Use a state updater function to ensure we work with the latest state
          setDocuments(currentDocs => {
            const docExists = currentDocs.some(doc => doc.id === newDocData.id);
            if (docExists) {
               console.log(`Realtime: Updating existing document ${newDocData.id}`);
               return currentDocs.map(doc => 
                 doc.id === newDocData.id ? { ...doc, ...newDocData } : doc // Use asserted type
               );
            } else {
               console.log(`Realtime: Received update for unknown document ${newDocData.id}. Fetching full list.`);
               // Fetch full list if the updated doc isn't known (edge case)
               fetchDocuments(); 
               return currentDocs; // Return current state until fetch completes
            }
          });

          // Fetch financial data only if the document specifically completed processing
          // Use the asserted type here as well
          if ('processing_status' in newDocData && newDocData.processing_status === 'completed') {
            console.log('Realtime: Document processing completed, fetching latest financial metrics');
            fetchFinancialData(); // Calls the memoized function
          }
        }
      )
      // Modify the signature to explicitly type err as any when present
      .subscribe((status: 'SUBSCRIBED' | 'TIMED_OUT' | 'CHANNEL_ERROR' | 'CLOSED', err?: any) => {
        if (status === 'SUBSCRIBED') {
          console.log(`Realtime: Successfully subscribed to documents channel for company ${companyId}`);
          setRealtimeChannel(channel); // Store the active channel
        } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
          // Check if err exists before logging
          if (err) {
            console.error(`Realtime: Subscription error for company ${companyId}:`, status, err);
          } else {
            console.error(`Realtime: Subscription error for company ${companyId}:`, status, '(No error object provided)');
          }
          setError('Connection issue: Could not get live document updates.');
          setRealtimeChannel(null); // Clear state on error
        } else if (status === 'CLOSED') {
           console.log(`Realtime: Channel closed for company ${companyId}`);
           // Don't clear state here, allow potential resubscribe on next render?
           // setRealtimeChannel(null);
        }
      });

    // Cleanup function: Only remove the channel specifically created in this effect instance
    return () => {
      if (channel) { // Reference the channel created in *this* effect closure
        console.log(`Removing Realtime subscription for company ${companyId} on effect cleanup (channel ${channel.topic})`);
        supabase.removeChannel(channel).catch((err: any) => { // Explicitly type err
          console.error('Error removing realtime channel on cleanup:', err);
        });
        // Avoid clearing realtimeChannel state here if it might belong to a different companyId instance
      }
    };
  // --- REMOVED: realtimeChannel from dependencies --- 
  }, [supabase, companyId, fetchDocuments, fetchFinancialData, setRealtimeChannel, setError]); // Keep stable dependencies

  // --- ADDED: Effect to handle navigation after state update ---
  useEffect(() => {
    if (pendingRecommendationNavigation) {
      console.log('[Navigation Effect] Pending navigation detected, going to step 5.');
      goToStep(5);
      setPendingRecommendationNavigation(false); // Reset the flag
    }
  }, [pendingRecommendationNavigation, goToStep]); // Added goToStep dependency

  // --- ADDED: Setup Realtime listener for documents and funding_recommendations ---
  useEffect(() => {
    // Only run if supabase client and companyId are available
    if (!supabase || !companyId) return;

    // console.log('[RT Setup] Setting up Realtime channel for company:', companyId);

    // --- MODIFIED: Subscribe to both documents and funding_recommendations ---
    const channel = supabase
      .channel(`onboarding-flow-${companyId}`)
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'documents',
          filter: `company_id=eq.${companyId}`,
        },
        (payload: RealtimePostgresChangesPayload<any>) => {
          // console.log('[RT Documents] Change received!', payload);
          // Update the local documents state if a change occurs
          setDocuments((currentDocs) =>
            currentDocs.map((doc) =>
              doc.id === payload.new.id ? { ...doc, ...payload.new } : doc
            )
          );

          // Refetch financial data if a document status changes to 'processed'
          // Add type check for payload.old
          if (payload.old && typeof payload.old === 'object' && 'status' in payload.old && payload.old?.status !== 'processed' && payload.new.status === 'processed') {
            // console.log('[RT Documents] Document processed, refetching financials...');
            // fetchFinancialData(companyId ?? ''); // Add nullish coalescing for companyId
            // --- MODIFIED: Trigger refetch instead of calling non-existent function ---
            setRefetchTrigger(prev => prev + 1);
          }
        }
      )
      // --- ADDED: Listener for funding_recommendations ---
      .on(
        'postgres_changes',
        {
          event: 'INSERT', // Listen for new recommendations
          schema: 'public',
          table: 'funding_recommendations',
          filter: `company_id=eq.${companyId}`,
        },
        (payload: RealtimePostgresChangesPayload<any>) => {
          console.log('[RT Recommendations] New recommendation received!', payload);
          console.log('[RT Recommendations] Recommendation received. Stopping loader and queueing navigation.');
          // --- FIX: Reset the correct loader state --- 
          setIsGeneratingRecommendations(false); 
          // --- END FIX ---
          setPendingRecommendationNavigation(true); 
        }
      )
      .subscribe((status: string) => {
        if (status === 'SUBSCRIBED') {
          // console.log('[RT Setup] Successfully subscribed to channel!');
        } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
          console.error('[RT Setup] Realtime subscription error:', status);
          toast({
            title: t('realtime.errorTitle'),
            description: t('realtime.errorMessage'),
            variant: 'destructive',
          });
        }
      });

    setRealtimeChannel(channel);

    // Cleanup function to remove the channel subscription
    return () => {
      // console.log('[RT Cleanup] Removing Realtime channel subscription');
      if (channel) {
        supabase.removeChannel(channel);
        setRealtimeChannel(null);
      }
    };
    // Add isGeneratingRecommendations to dependencies
  }, [supabase, companyId, currentStep, t]); // Removed isGeneratingRecommendations from deps

  // --- ADDED: Fetch Financing Needs Amount for Step 6 Prefill ---
  const fetchFinancingNeedsAmount = async () => {
    if (!companyId || !session) return;
    console.log(`Fetching financing needs amount for company: ${companyId}`);
    try {
      const { data, error } = await supabase
        .from('financing_needs')
        .select('amount') // Correct: Select the 'amount' column directly
        .eq('company_id', companyId)
        .order('created_at', { ascending: false })
        .limit(1)
        .single();

      if (error) {
        // Don't block the user, just log the error
        console.error('Error fetching financing needs amount:', error);
        // Optionally reset amount if fetch fails?
        // setApplicationFormData(prev => ({ ...prev, amount: '' })); 
        return;
      }

      if (data && data.amount !== null && data.amount !== undefined) { // Correct: Check the 'amount' property
        console.log('Prefilling application amount from financing needs:', data.amount);
        setApplicationFormData(prev => ({ ...prev, amount: data.amount })); // Correct: Use data.amount
      } else {
        console.log('No funding amount found in financing needs.');
        // Optionally reset amount if no value found?
        // setApplicationFormData(prev => ({ ...prev, amount: '' })); 
      }
    } catch (err) {
      console.error('Unexpected error fetching financing needs amount:', err);
    }
  };

  // --- Handler for Checkbox Changes --- Added
  const handleCheckboxChange = (name: string, checked: boolean) => {
    setInitialFormData(prev => ({
      ...prev,
      [name]: checked
    }));
  };

  // --- Initialize default term_months for Step 6 --- 
  useEffect(() => {
    // Only run this effect when entering Step 6 AND if the type requires a term
    if (currentStep === 6 && (fundingType === 'business_loan' || fundingType === 'credit_line')) {
      // Check if term_months is currently not a positive number (e.g., empty string, 0, null)
      if (!applicationFormData.term_months || Number(applicationFormData.term_months) <= 0) {
        console.log('Initializing default term_months to 12 for Step 6');
        // Set the default value in the state
        setApplicationFormData(prev => ({ ...prev, term_months: 12 }));
      }
    }
    // Add dependencies: run when step or relevant funding type changes
  }, [currentStep, fundingType]); 

  // --- NEW useEffect to handle navigation after applicationId is set ---
  useEffect(() => {
    // Check if we intend to go to step 7 AND if the applicationId is now set
    if (nextStepTarget === 7 && applicationId) {
      console.log(`Navigating to Step 7 now that applicationId (${applicationId}) is set.`);
      goToStep(7);
      setNextStepTarget(null); // Reset the navigation trigger
    }
  }, [applicationId, nextStepTarget]); // Depend on applicationId and the trigger state

  // Handler for saving the draft application (Step 6 submit)
  const handleSaveDraftApplication = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setError(null);
    setLoading(true);
    setNextStepTarget(null); // Clear any previous navigation intent

    // --- Validation ---
    if (!fundingType) {
      // Use t() to translate the error key
      setError(t('step6.validationErrorRequired'));
      setLoading(false);
      return;
    }
    
    // Enhanced validation for funding amount with min/max limits
    const amountValue = Number(applicationFormData.amount);
    if (!applicationFormData.amount || amountValue <= 0) {
      setError(t('error.invalidAmount', { default: 'Please enter a valid funding amount.' }));
      setLoading(false);
      return;
    }
    if (amountValue < 1000) {
      setError(t('step6.amountTooSmall', { default: 'Minimum amount is 1,000 â‚¬' }));
      setLoading(false);
      return;
    }
    if (amountValue > 5000000) {
      setError(t('step6.amountTooLarge', { default: 'Maximum amount is 5,000,000 â‚¬' }));
      setLoading(false);
      return;
    }
    
    // Only validate term_months if required for the selected funding type
    if ((fundingType === 'business_loan' || fundingType === 'credit_line') && 
        (!applicationFormData.term_months || Number(applicationFormData.term_months) <= 0)) {
      // Use a specific translated key if needed, or a general one
      setError(t('error.invalidTerm', { default: 'Please select a valid loan term.'}));
      setLoading(false);
      return;
    }
    // --- End Validation ---

    if (!companyId) {
      setError(t('error.noCompanySelected', { default: 'Please select a company first.' }));
      setLoading(false);
      return;
    }

    let resolvedFinancingNeedsId: string | null = financingNeedsId; // Start with state value

    // --- ADDED: Fetch financingNeedsId from DB if not in state ---
    if (!resolvedFinancingNeedsId) {
      console.log('FinancingNeedsId not in state, attempting to fetch latest from DB...');
      try {
        const { data: latestNeeds, error: fetchNeedsError } = await supabase
          .from('financing_needs')
          .select('id')
          .eq('company_id', companyId)
          .order('created_at', { ascending: false })
          .limit(1)
          .maybeSingle();

        if (fetchNeedsError) {
          console.error('Error fetching latest financing_needs:', fetchNeedsError);
          throw new Error('Failed to check previous funding needs data.');
        }

        if (latestNeeds?.id) {
          console.log('Found latest financingNeedsId from DB:', latestNeeds.id);
          resolvedFinancingNeedsId = latestNeeds.id;
          // Optionally update state if needed, though not strictly necessary here
          // setFinancingNeedsId(latestNeeds.id);
        } else {
          console.warn('No financing_needs record found in DB for this company.');
          setError(t('error.step4Incomplete', { default: 'Funding needs information is missing. Please complete Step 4 first.' }));
          setLoading(false);
          return;
        }
      } catch (err) {
        console.error('Error during financing_needs fetch:', err);
        setError(err instanceof Error ? err.message : 'An error occurred checking funding needs.');
        setLoading(false);
        return;
      }
    }
    // --- END Fetch Fallback ---

    // If resolvedFinancingNeedsId is still null after check/fetch, something went wrong
    if (!resolvedFinancingNeedsId) {
        console.error('Critical Error: resolvedFinancingNeedsId is null after state check and DB fetch attempt.');
        setError('Could not determine funding needs reference. Please contact support or try Step 4 again.');
        setLoading(false);
        return;
    }

    try {
      const { data: applicationData, error: applicationError } = await supabase
        .from('funding_applications')
        .insert([
          {
            company_id: companyId,
            user_id: user?.id,
            amount: Number(applicationFormData.amount),
            term_months: (fundingType === 'business_loan' || fundingType === 'credit_line') && applicationFormData.term_months 
              ? Number(applicationFormData.term_months) 
              : null, 
            type: fundingType, 
            status: 'draft',
            funding_recommendation_id: applicationFormData.funding_recommendation_id,
            applicant_details: {},
            // --- Use the resolved ID (from state OR DB fetch) ---
            financing_needs_id: resolvedFinancingNeedsId 
          }
        ])
        .select()
        .single();

      if (applicationError) throw applicationError;

      console.log('Draft application saved:', applicationData);
      setLatestApplicationData(applicationData);

      if (applicationData?.id) {
        setApplicationId(applicationData.id);
        console.log(`Application ID state set to: ${applicationData.id}`);
        setNextStepTarget(7);
      } else {
        console.error("Error: Application ID missing from saved draft data.");
        setError(t('error.saveDraftFailed', { default: 'Failed to save application draft (missing ID). Please try again.' }));
      }

    } catch (err: any) {
      console.error("Error saving draft application:", err);
      setError(t('error.saveDraftFailed', { default: 'Failed to save application draft. Please try again.' }));
    } finally {
      setLoading(false);
    }
  };

  // --- MODIFIED: useEffect to fetch company data AND application ID ---
  useEffect(() => {
    const fetchData = async () => {
      if (companyId) {
        console.log(`ðŸ”„ [OnboardingFlow] Company ID changed or component mounted: ${companyId}. Fetching data...`);
        setLoading(true);
        setError(null);
        try {
          // Fetch company data using the memoized function
          const selectedCompany = await fetchSelectedCompanyData(companyId);
          setCompanyData(selectedCompany); // Set state with fetched data

          // --- ADDED: Fetch latest Application ID if missing or doesn't match company ---
          // Check if we need to fetch the application ID
          if (!applicationId) { // Fetch only if it's null
             console.log(`ðŸ” [OnboardingFlow] Application ID missing. Fetching latest for company: ${companyId}`);
             const { data: appData, error: appError } = await supabase
               .from('funding_applications')
               .select('id')
               .eq('company_id', companyId)
               .order('created_at', { ascending: false })
               .limit(1)
               .maybeSingle();

             if (appError) {
               console.error(`âŒ [OnboardingFlow] Error fetching latest application ID:`, appError);
               // Decide if this error should be shown to the user
               // setError('Failed to load application status.');
             } else if (appData) {
               console.log(`âœ… [OnboardingFlow] Found latest Application ID: ${appData.id}`);
               setApplicationId(appData.id);
             } else {
               console.log(`â„¹ï¸ [OnboardingFlow] No existing application found for company ${companyId}.`);
               setApplicationId(null); // Explicitly set to null if none found
             }
           } else {
             // Optional: Verify if the existing applicationId belongs to the current companyId
             // This might be needed if the user switches companies mid-flow
             console.log(`â„¹ï¸ [OnboardingFlow] Application ID already present: ${applicationId}. Skipping fetch.`);
           }
          // --- END: Fetch latest Application ID ---

        } catch (err: any) {
          console.error(`âŒ [OnboardingFlow] Error in main fetchData useEffect for ${companyId}:`, err);
          setError(`Failed to load company/application data: ${err.message}`);
          setCompanyData(null);
          setApplicationId(null); // Reset application ID on error
        } finally {
          setLoading(false);
        }
      } else {
        // Reset data if companyId becomes null
        console.log('â„¹ï¸ [OnboardingFlow] Company ID is null. Resetting related states.');
        setCompanyData(null);
        setFinancialDataArray([]);
        setFundingRecommendations([]);
        setApplicationId(null); // Reset application ID
        setApplicationFormData({ amount: '', term_months: '', funding_recommendation_id: null });
      }
    };

    fetchData();
    // Ensure fetchSelectedCompanyData is stable (memoized above)
  }, [companyId, supabase, applicationId, fetchSelectedCompanyData, refetchTrigger]); // Added refetchTrigger dependency

  // --- ADDED BACK: Handle initial form data change ---
  const handleInitialFormChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setInitialFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  // --- END ADDED BACK ---

  // --- ADD BACK File Handling Functions --- 
  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    console.log("File input change event triggered");
    if (e.target.files && e.target.files.length > 0) {
      console.log(`Selected ${e.target.files.length} files:`, Array.from(e.target.files).map(f => f.name).join(', '));
      const files = Array.from(e.target.files);
      setUploadedFiles(files);
      e.target.value = ''; // Reset input value
      console.log("Starting automatic file upload");
      handleFileUpload(files).catch(err => {
        console.error("Error in automatic file upload:", err);
        setError(err instanceof Error ? err.message : "File upload failed");
      });
    } else {
      console.log("No files selected in file input");
    }
  };

  const handleFileUpload = async (files: File[]) => {
    console.log(`handleFileUpload called with ${files.length} files`);
    if (!session?.user || !companyId) {
      console.error('Cannot upload: No session user or company ID');
      setError('Please sign in and select a company before uploading files');
      return;
    }
    setUploading(true);
    setError(null);
    const uploadedDocIds: string[] = [];
    try {
      console.log('Creating upload promises for files:', files.map(f => f.name).join(', '));
      const uploadPromises = files.map(async (file) => {
        console.log(`Preparing to upload file: ${file.name} (${formatFileSize(file.size)})`);
        const formData = new FormData();
        formData.append('file', file);
        formData.append('companyId', companyId);
        const fiscalYear = financialDataArray[0]?.fiscal_year?.toString() || new Date().getFullYear().toString();
        const fiscalPeriod = financialDataArray[0]?.fiscal_period || 'annual';
        formData.append('fiscalYear', fiscalYear);
        formData.append('fiscalPeriod', fiscalPeriod);
        console.log(`Sending upload request for ${file.name} to /api/documents/upload`);
        const response = await fetch('/api/documents/upload', {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${session.access_token}` },
          body: formData
        });
        if (!response.ok) {
          console.error(`Upload failed for ${file.name} with status ${response.status}`);
          throw new Error(`Upload failed for ${file.name} with status ${response.status}`);
        }
        console.log(`Successfully uploaded ${file.name}`);
        const result = await response.json();
        if (result.data?.id) {
            uploadedDocIds.push(result.data.id);
        }
        return result;
      });
      console.log('Waiting for all uploads to complete...');
      const uploadResults = await Promise.all(uploadPromises);
      console.log('All uploads completed, refreshing document list initially');
      await fetchDocuments(); // Refresh document list
      if (uploadedDocIds.length > 0 && companyId) {
        console.log('Triggering financial analysis for uploaded documents:', uploadedDocIds);
        try {
          const analysisResponse = await fetch('/api/documents/analyze', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${session.access_token}` },
            body: JSON.stringify({ company_id: companyId, document_ids: uploadedDocIds })
          });
          if (analysisResponse.ok) {
            console.log('Financial analysis trigger request sent successfully');
            const analysisResult = await analysisResponse.json();
            console.log('Analysis trigger response:', analysisResult);
            // Realtime will handle refresh
          } else {
            console.error('Failed to trigger financial analysis:', await analysisResponse.text());
            setError('Failed to start document analysis process.');
          }
        } catch (analysisError) {
          console.error('Error triggering financial analysis:', analysisError);
          setError('An error occurred while starting the analysis.');
        }
      }
    } catch (err) {
      console.error('Error in handleFileUpload:', err);
      setError(err instanceof Error ? err.message : 'Upload failed');
    } finally {
      setUploading(false);
      setUploadedFiles([]); // Clear the selection
    }
  };

  // Handle step 2 form submission - company info
  const handleStep2Submit = async (e: React.FormEvent<HTMLFormElement>) => {
    // Check if it's a real event before preventing default
    if (e && typeof e.preventDefault === 'function') {
        e.preventDefault(); 
    }

    console.log('[handleStep2Submit] Triggered. companyData:', companyData, 'selectedCompany:', companyFormData.selectedCompany);

    if (!session) {
      setError(t('error.notAuthenticated', { default: 'Authentication session missing. Please sign in again.' }));
      return;
    }
    
    // --- Added logic to handle the case where companyData already exists (Continue button) ---
    if (companyData && !companyFormData.selectedCompany) {
        console.log("[handleStep2Submit] Continuing with existing company data (condition met):");
        // Skip API call, directly use existing company data and analysis status
        if (companyData.id) {
            setCompanyId(companyData.id); // Ensure companyId is set
            await storeFinancialMetrics(companyData); // Ensure metrics are stored if needed
            // Check if analysis_status exists before accessing it
            if (companyData.analysis_status === 'pending') {
              setIsAnalyzing(true);
            } else if (companyData.analysis_status === 'completed') {
              setAnalysisResult(companyData.analysis_result);
            }
            console.log('[handleStep2Submit] Navigating to Step 3 (existing company case)...');
            goToStep(3); // Navigate to the next step
            return; // Stop execution here
        } else {
            console.error('[handleStep2Submit] Existing company data is missing an ID.');
            setError("Existing company data is missing an ID.");
            return;
        }
    }
    // --- End added logic ---

    console.log('[handleStep2Submit] Proceeding with API call/validation logic...');
    setLoading(true);
    setError(null);

    if (!companyFormData.name || !companyFormData.code) {
      setError(t('error.companyInfoRequired', { default: 'Company name and code are required.' }));
      setLoading(false);
      return;
    }

    try {
      // Determine if we are CREATING a NEW company or UPDATING the selected one
      const isUpdating = !!companyId; // If a companyId is set, assume update
      console.log(`Step 2 Submit: ${isUpdating ? 'Updating' : 'Creating'} company...`);
      
      const payload: any = {
        name: companyFormData.name,
        business_id: companyFormData.code,
        // Include YTJ data ONLY if it was freshly selected via search during THIS step
        ...(companyFormData.selectedCompany && { 
            ...companyFormData.selectedCompany 
        })
      };
      
      // Adjust API call based on update/create
      const apiEndpoint = isUpdating ? `/api/companies/update/${companyId}` : '/api/companies/create';
      const apiMethod = isUpdating ? 'PUT' : 'POST';

      const companyResponse = await fetch(apiEndpoint, {
        method: apiMethod, 
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${session.access_token}`
        },
        body: JSON.stringify(payload)
      });

      const responseText = await companyResponse.text();
      console.log('Raw API response text:', responseText);

      if (!companyResponse.ok) {
        // Handle errors (keep existing logic)
        if (companyResponse.status === 409) {
           // ... existing conflict error handling ...
            setError(t('error.companyConflict', { default: 'A company with this Business ID already exists.' }));
        } else {
           // ... existing generic error handling ...
          setError(t('error.saveCompany', { default: 'Could not save company information.' }));
        }
        setLoading(false);
        return;
      } 
      
      // Successfully saved/updated company
      console.log(`Company info ${isUpdating ? 'updated' : 'created/enriched'} successfully.`);
      const savedCompanyData = JSON.parse(responseText);
      
      if (savedCompanyData?.id) {
        // If CREATING, add to userCompanies list and set as selected
        if (!isUpdating) {
            setUserCompanies((prev: CompanyRow[]) => [...prev, savedCompanyData]); // Add new company to list
            setCompanyId(savedCompanyData.id); // Select the newly created company
        } else {
            // If UPDATING, update the entry in userCompanies list
            setUserCompanies((prev: CompanyRow[]) => prev.map(comp => comp.id === savedCompanyData.id ? savedCompanyData : comp));
            // No need to setCompanyId again if updating the currently selected one
        }
        setCompanyData(savedCompanyData); // Update the detailed data for the selected company
        console.log('Stored/Updated company data:', savedCompanyData);
        
        await storeFinancialMetrics(savedCompanyData);
        
        // Check if analysis_status exists before accessing it
        if (savedCompanyData.analysis_status === 'pending') {
          setIsAnalyzing(true);
        } else if (savedCompanyData.analysis_status === 'completed') {
          setAnalysisResult(savedCompanyData.analysis_result);
        }
      } else {
        console.error('Company ID not available in response.');
        setError('Failed to get Company ID after saving.');
      }

      goToStep(3);

    } catch (err) {
      // Re-determine isUpdating in the catch block for safety
      const isUpdatingInCatch = !!companyId;
      console.error(`Error during Step 2 ${isUpdatingInCatch ? 'update' : 'submission'}:`, err);
      setError(err instanceof Error ? err.message : t('error.step2Submit', { default: 'An unexpected error occurred.' }));
      setLoading(false);
    }
  };

  useEffect(() => {
    let analysisTimeoutId: NodeJS.Timeout | null = null;
    
    if (isGeneratingRecommendations) {
      analysisTimeoutId = setTimeout(() => {
        console.log('Analysis timeout reached (120s) - stopping loader and redirecting to next step');
        setIsGeneratingRecommendations(false);
        goToStep(5);
      }, 120000);
    }
    
    return () => {
      if (analysisTimeoutId) {
        clearTimeout(analysisTimeoutId);
      }
    };
  }, [isGeneratingRecommendations, goToStep]);

  // --- MODIFIED: Consolidated Realtime subscription for all events with improved stability and reconnection ---
  useEffect(() => {
    // Only run if supabase client and companyId are available
    if (!supabase || !companyId) return;

    console.log(`ðŸ”Œ [RT Setup] Setting up consolidated Realtime channel for company: ${companyId}`);
    
    // Use a ref-like approach with a stable reference to prevent recreation
    const channelId = `consolidated-events-${companyId}`;
    let channelClosed = false;
    let retryCount = 0;
    const MAX_RETRIES = 5;
    const RETRY_DELAY_MS = 3000;
    
    // Function to create a channel with all necessary subscriptions
    const createChannel = () => {
      console.log(`ðŸ”„ [RT Setup] Creating Realtime channel (attempt ${retryCount + 1})...`);
      
      // Use single channel for all events
      const channel = supabase
        .channel(channelId)
        // Document updates
        .on(
          'postgres_changes',
          {
            event: 'UPDATE',
            schema: 'public',
            table: 'documents',
            filter: `company_id=eq.${companyId}`,
          },
          (payload: RealtimePostgresChangesPayload<any>) => {
            if (channelClosed) return; // Skip if channel is being closed
            
            console.log('ðŸ“„ [RT Documents] Document change received:', 
                        payload.new?.id, 
                        payload.new?.processing_status);
            
            // Update the local documents state if a change occurs
            setDocuments((currentDocs) =>
              currentDocs.map((doc) =>
                doc.id === payload.new.id ? { ...doc, ...payload.new } : doc
              )
            );

            // Trigger refetch if document status changes to 'processed'
            if (payload.old && 
                typeof payload.old === 'object' && 
                'processing_status' in payload.old && 
                payload.old?.processing_status !== 'completed' && 
                payload.new?.processing_status === 'completed') {
              console.log('ðŸ“Š [RT Documents] Document processing completed, triggering financial data refetch');
              setRefetchTrigger(prev => prev + 1);
              fetchFinancialData();
            }
          }
        )
        // Funding recommendations - watch for both INSERT and UPDATE
        .on(
          'postgres_changes',
          {
            event: '*', // Watch all events to be safe
            schema: 'public',
            table: 'funding_recommendations',
            filter: `company_id=eq.${companyId}`,
          },
          (payload: RealtimePostgresChangesPayload<any>) => {
            if (channelClosed) return; // Skip if channel is being closed
            
            console.log(`ðŸ’° [RT Recommendations] Event received: ${payload.eventType}`, 
                        'ID:', payload.new?.id, 
                        'Company ID:', payload.new?.company_id);
            
            // Only react to new recommendations
            if (payload.eventType === 'INSERT' || 
               (payload.eventType === 'UPDATE' && 
                payload.old?.status !== 'completed' && 
                payload.new?.status === 'completed')) {
              
              console.log('âœ… [RT Recommendations] New/completed recommendation detected! Stopping loader and queueing navigation.');
              
              // Reset loading state
              setIsGeneratingRecommendations(false);
              
              // Queue navigation to step 5
              setPendingRecommendationNavigation(true);
            }
          }
        )
        .subscribe((status: string, err?: any) => {
          if (status === 'SUBSCRIBED') {
            console.log('âœ… [RT Setup] Successfully subscribed to consolidated channel!');
            // Reset retry count on successful subscription
            retryCount = 0;
            // Store the active channel in state once successfully subscribed
            setRealtimeChannel(channel);
          } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
            const errMessage = err ? 
              (typeof err === 'object' && err.message ? err.message : JSON.stringify(err)) : 
              '(No error details available)';
            
            console.error(`âŒ [RT Setup] Realtime subscription error: ${status}`, errMessage);
            
            // Implement retry logic for reconnection
            if (retryCount < MAX_RETRIES && !channelClosed) {
              retryCount++;
              console.log(`ðŸ”„ [RT Retry] Attempting to reconnect (${retryCount}/${MAX_RETRIES}) in ${RETRY_DELAY_MS}ms`);
              
              // Try to remove the failed channel first
              try {
                supabase.removeChannel(channel);
              } catch (e) {
                console.warn('Could not remove failed channel:', e);
              }
              
              // Set a timeout to retry connection
              setTimeout(() => {
                if (!channelClosed) {
                  try {
                    // Create a new channel
                    const newChannel = createChannel();
                    // No need to set state here as it will be set on successful subscription
                  } catch (retryErr) {
                    console.error('[RT Retry] Failed to create new channel:', retryErr);
                  }
                }
              }, RETRY_DELAY_MS);
            } else if (!channelClosed) {
              // If max retries reached, show a user-friendly message
              console.error(`âŒ [RT Error] Max retries (${MAX_RETRIES}) reached for Realtime connection`);
              toast({
                title: t('realtime.errorTitle'),
                description: t('realtime.errorMessage'),
                variant: 'destructive',
              });
            }
          } else if (status === 'CLOSED') {
            console.log('ðŸšª [RT Setup] Channel closed');
            channelClosed = true;
            // Could implement reconnection here too if needed
          }
        });
      
      return channel;
    };
    
    // Initialize the channel
    const initialChannel = createChannel();

    // Cleanup function to remove the channel subscription
    return () => {
      console.log(`ðŸ§¹ [RT Cleanup] Removing Realtime channel subscription for company ${companyId}`);
      channelClosed = true;
      if (initialChannel) {
        // Use try/catch to prevent unhandled errors during cleanup
        try {
          supabase.removeChannel(initialChannel);
        } catch (err) {
          console.error('Error removing channel:', err);
        }
      }
    };
  }, [supabase, companyId, t]); // Minimized dependencies

  // --- MODIFIED: Recommendation polling fallback with improved stability ---
  useEffect(() => {
    // Only run polling if recommendations are being generated
    if (!isGeneratingRecommendations || !companyId || !session) return;
    
    console.log('â±ï¸ [Fallback] Starting recommendation polling fallback');
    const pollInterval = 5000; // Poll every 5 seconds
    const maxAttempts = 24; // Maximum 2 minutes of polling (24 * 5s = 120s)
    let attempts = 0;
    let stopped = false;
    
    const checkForRecommendations = async () => {
      if (stopped) return false;
      
      try {
        console.log(`ðŸ” [Fallback] Polling for recommendations (attempt ${attempts + 1}/${maxAttempts})`);
        
        // Check if we have recommendations for this company
        const { data, error } = await supabase
          .from('funding_recommendations')
          .select('id, created_at')
          .eq('company_id', companyId)
          .order('created_at', { ascending: false })
          .limit(1);
          
        if (error) {
          console.error('âŒ [Fallback] Error checking recommendations:', error);
          return false;
        }
        
        if (stopped) return false; // Check if stopped after async operation
        
        if (data && data.length > 0) {
          // Found recommendation(s)
          const recommendationTime = new Date(data[0].created_at).getTime();
          const now = Date.now();
          const ageInSeconds = (now - recommendationTime) / 1000;
          
          console.log(`âœ… [Fallback] Found recommendation! ID: ${data[0].id}, Age: ${ageInSeconds.toFixed(1)}s`);
          
          // Only consider it a match if it's relatively recent (created in the last 5 minutes)
          if (ageInSeconds < 300) {
            if (stopped) return false; // Check if stopped before state updates
            
            // Stop the generating indicator and queue navigation
            setIsGeneratingRecommendations(false);
            setPendingRecommendationNavigation(true);
            return true;
          } else {
            console.log(`âš ï¸ [Fallback] Found recommendation but it's too old (${ageInSeconds.toFixed(1)}s)`);
          }
        }
        
        return false;
      } catch (err) {
        console.error('âŒ [Fallback] Unexpected error in recommendation polling:', err);
        return false;
      }
    };
    
    const intervalId = setInterval(async () => {
      if (stopped) {
        clearInterval(intervalId);
        return;
      }
      
      attempts++;
      const found = await checkForRecommendations();
      
      if (found || attempts >= maxAttempts) {
        console.log(`ðŸ›‘ [Fallback] Stopping recommendation polling: ${found ? 'Found recommendation' : 'Max attempts reached'}`);
        clearInterval(intervalId);
        
        // If max attempts reached and still no recommendation, force navigation
        if (!found && attempts >= maxAttempts && !stopped) {
          console.warn('âš ï¸ [Fallback] Max polling attempts reached. Forcing navigation to Step 5.');
          setIsGeneratingRecommendations(false);
          goToStep(5);
        }
      }
    }, pollInterval);
    
    // Initial check immediately - safely invoke async function
    void checkForRecommendations();
    
    // Cleanup
    return () => {
      stopped = true;
      clearInterval(intervalId);
      console.log('ðŸ§¹ [Fallback] Cleanup: Stopped recommendation polling');
    };
  }, [isGeneratingRecommendations, companyId, session, supabase, goToStep]); // Removed function dependencies

  // --- MODIFIED: Timeout effect with improved stability ---
  useEffect(() => {
    let analysisTimeoutId: NodeJS.Timeout | null = null;
    let cancelled = false;
    
    if (isGeneratingRecommendations) {
      analysisTimeoutId = setTimeout(() => {
        if (cancelled) return;
        
        console.log('Analysis timeout reached (120s) - stopping loader and redirecting to next step');
        setIsGeneratingRecommendations(false);
        goToStep(5);
      }, 120000);
    }
    
    return () => {
      cancelled = true;
      if (analysisTimeoutId) {
        clearTimeout(analysisTimeoutId);
      }
    };
  }, [isGeneratingRecommendations, goToStep]);

  // In the main OnboardingFlow component function, after the declaration of all state variables:

  // Add a custom event listener for recommendation readiness notifications from Step5Summary
  useEffect(() => {
    const handleRecommendationsReady = (event: CustomEvent<{companyId: string}>) => {
      const { companyId: eventCompanyId } = event.detail;
      console.log(`ðŸ“£ [Event] Received recommendations-ready event for company: ${eventCompanyId}`);
      
      // Refresh the recommendations if this is for the current company
      if (eventCompanyId === companyId) {
        console.log('ðŸ”„ [OnboardingFlow] Refreshing recommendations after notification from Step5Summary');
        // Force the refresh regardless of whether we're already fetching
        setIsFetchingRecommendations(false);
        // Add a small delay to ensure state is updated
        setTimeout(() => {
          fetchFundingRecommendations();
          // After successful fetch, turn off the generating indicator
          setIsGeneratingRecommendations(false);
        }, 300);
      }
    };

    // Add event listener
    if (typeof window !== 'undefined') {
      window.addEventListener('recommendations-ready', handleRecommendationsReady as EventListener);
    }

    // Clean up
    return () => {
      if (typeof window !== 'undefined') {
        window.removeEventListener('recommendations-ready', handleRecommendationsReady as EventListener);
      }
    };
  }, [companyId, fetchFundingRecommendations]);

  // Add a direct check for recommendations when appropriate
  useEffect(() => {
    // Only check if we're on step 5, generating recommendations, and no recommendations loaded yet
    const shouldCheckDirectly = 
      currentStep === 5 && 
      isGeneratingRecommendations && 
      (!fundingRecommendations || fundingRecommendations.length === 0);
    
    if (shouldCheckDirectly && companyId && !isFetchingRecommendations) {
      console.log('ðŸ” [OnboardingFlow] Directly checking for recommendations on step 5');
      fetchFundingRecommendations();
      
      // Set up a polling interval as fallback
      const pollingInterval = setInterval(() => {
        if (!isGeneratingRecommendations || fundingRecommendations?.length > 0) {
          console.log('ðŸ›‘ [OnboardingFlow] Stopping direct polling - recommendations found or generation stopped');
          clearInterval(pollingInterval);
          return;
        }
        
        console.log('ðŸ”„ [OnboardingFlow] Polling for recommendations directly');
        fetchFundingRecommendations();
      }, 10000); // Check every 10 seconds
      
      return () => {
        clearInterval(pollingInterval);
      };
    }
  }, [currentStep, companyId, isGeneratingRecommendations, fundingRecommendations, isFetchingRecommendations]);

  // Add a LocalStorage check as backup communication channel
  useEffect(() => {
    // Skip if we're not on Step 5 or not generating recommendations
    if (currentStep !== 5 || !isGeneratingRecommendations || !companyId) {
      return;
    }
    
    // Check localStorage for recommendations readiness
    const checkLocalStorage = () => {
      if (!companyId) return;
      
      try {
        const signalStr = localStorage.getItem('recommendations_ready_signal');
        if (!signalStr) return;
        
        const signal = JSON.parse(signalStr);
        
        // Check if the signal is for the current company and is recent (within last 10 minutes)
        if (
          signal.companyId === companyId && 
          signal.timestamp > Date.now() - 10 * 60 * 1000
        ) {
          console.log('ðŸ”” [OnboardingFlow] Detected recommendation readiness via localStorage');
          
          // Clear the signal to prevent reprocessing
          localStorage.removeItem('recommendations_ready_signal');
          
          // Force refresh recommendations
          fetchFundingRecommendations();
          setIsGeneratingRecommendations(false);
        }
      } catch (err) {
        console.error('âŒ [OnboardingFlow] Error checking localStorage signal:', err);
      }
    };
    
    // Initial check
    checkLocalStorage();
    
    // Set up interval to check periodically
    const interval = setInterval(checkLocalStorage, 5000);
    
    return () => {
      clearInterval(interval);
    };
  }, [currentStep, isGeneratingRecommendations, companyId, fetchFundingRecommendations]);

  // Add state for recommendation selection
  const [selectedRecommendation, setSelectedRecommendation] = useState<any>(null);

  // Handle step 4 submit (Funding Needs)
  const handleStep4Submit = async (questionnaireData: any) => {
    console.log("Received Questionnaire Data in OnboardingFlow (Step 4):", questionnaireData);

    if (!session || !companyId) {
      setError(t('error.notAuthenticated', { default: 'Authentication session or Company ID missing. Please sign in again or select a company.' }));
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Store questionnaire responses
      const { data: needs, error: needsError } = await supabase
        .from('financing_needs')
        .insert({
          company_id: companyId,
          purpose: questionnaireData.purpose,
          amount: questionnaireData.amount,
          timeline: questionnaireData.timeline,
          factoring_monthlyInvoices: questionnaireData.factoring_monthlyInvoices,
          factoring_paymentDays: questionnaireData.factoring_paymentDays,
          factoring_customerLocation: questionnaireData.factoring_customerLocation,
          funding_needs: JSON.stringify(questionnaireData.funding_needs),
          company_situation: questionnaireData.company_situation,
          current_revenue: questionnaireData.current_revenue,
          company_situation_details: questionnaireData.company_situation_details,
          collateral_options: questionnaireData.collateral_options,
          collateral_details: questionnaireData.collateral_details
        })
        .select()
        .single();

      if (needsError) {
        console.error('Error saving financing needs:', needsError);
        setError(needsError.message);
        return;
      }
  return (
    <div className="min-h-[calc(100vh-213px)] bg-black text-gold-secondary flex flex-col">
      {/* --- FIX: Use isGeneratingRecommendations for loader visibility --- */}
      <EuroWhirlwindLoader 
         isVisible={isGeneratingRecommendations} 
         message={t('step3.generatingRecommendationsLoader', { default: 'Analyzing Documents & Generating Recommendations...' })} 
      />
      {/* --- END FIX --- */}

      {/* Header - only show on steps 2 and beyond */}
      {currentStep > 1 && (
        <header className="bg-black shadow-md shadow-gold-primary/10">
          {/* Header content */}
        </header>
      )}

      {/* Main content */}
      <main className="flex-1 flex flex-col">
        {/* Step indicator - Apply dark theme */}
        {currentStep > 1 && (
          <div className="py-8 bg-black border-b border-gray-dark">
            <div className="max-w-7xl mx-auto">
              {renderStepIndicator()}
            </div>
          </div>
        )}
        
        {/* Step content */}
        <div className="flex-1">
          {renderCurrentStep()}
        </div>
      </main>
    </div>
  );
} 